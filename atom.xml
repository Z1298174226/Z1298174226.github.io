<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>倾听枫声</title>
  <subtitle>lex-zhao</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lex-zhao.xyz/"/>
  <updated>2017-07-02T11:04:43.542Z</updated>
  <id>http://www.lex-zhao.xyz/</id>
  
  <author>
    <name>Lex-Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>弗洛伊德算法及证明</title>
    <link href="http://www.lex-zhao.xyz/2017/07/02/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E5%8F%8A%E8%AF%81%E6%98%8E/"/>
    <id>http://www.lex-zhao.xyz/2017/07/02/弗洛伊德算法及证明/</id>
    <published>2017-07-02T09:45:38.000Z</published>
    <updated>2017-07-02T11:04:43.542Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;弗洛伊德算法属于动态规划问题，通过插点的方式为加权图多源点间寻求最短路径。算法引入两个二维数组path[][]和dist[][],其中dist[i][j]描述两个节点i和j间的最短路径，path[i][j]用来描述节点i和j之间最短路径所经过的节点。&lt;br&gt;首先，初始化非相邻节点dist为INF，得到初始矩阵S，如图所示。&lt;br&gt;在此鸣谢&lt;a href=&quot;http://www.cnblogs.com/skywang12345所提供的图片&quot;&gt;http://www.cnblogs.com/skywang12345所提供的图片&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://opeygftv2.bkt.clouddn.com/01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Algorithm" scheme="http://www.lex-zhao.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ODL对packet_in消息的处理流程</title>
    <link href="http://www.lex-zhao.xyz/2017/06/03/OpenFlowJava%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.lex-zhao.xyz/2017/06/03/OpenFlowJava处理流程/</id>
    <published>2017-06-03T13:31:04.000Z</published>
    <updated>2017-06-03T13:52:51.695Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;OpenFlowJava对PakcetIn消息的处理流程&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;(1)当交换机遇到无法识别，或者需要上报的数据包（reason字段），通过与OpenFlowJava建立连接，向控制器发送消息。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SDN" scheme="http://www.lex-zhao.xyz/tags/SDN/"/>
    
      <category term="ODL" scheme="http://www.lex-zhao.xyz/tags/ODL/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾回收机制(二)——方法区回收</title>
    <link href="http://www.lex-zhao.xyz/2017/05/13/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E4%B8%80-%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.lex-zhao.xyz/2017/05/13/JVM-垃圾回收机制-一-——方法区回收/</id>
    <published>2017-05-13T15:46:01.000Z</published>
    <updated>2017-05-13T16:00:46.228Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;方法区（HotSpot中的永久代）并非没有垃圾回收机制，只是永久代的垃圾回收效率远远低于新生代回收效率。&lt;br&gt;永久代中垃圾回收主要包括两部分：废弃常量和无用的类。回收废弃常量与回收java堆中的对象非常相似，但判断一个类是否是无用的类就比较麻烦，类需要同时满足一下三个条件，才能算是无用的类：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
      <category term="GC机制" scheme="http://www.lex-zhao.xyz/tags/GC%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>（译）JVM 垃圾回收机制(一)——新生代垃圾回收</title>
    <link href="http://www.lex-zhao.xyz/2017/05/10/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.lex-zhao.xyz/2017/05/10/JVM-垃圾回收机制/</id>
    <published>2017-05-10T14:52:51.000Z</published>
    <updated>2017-05-13T12:34:11.962Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;原作者：PATRICK PESCHLOW&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文对原文有改动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单纯从 JVM 的功能考虑，并不需要新生代，完全可以针对整个堆进行操作。新生代存在的唯一理由是优化垃圾回收 (GC) 的性能。更具体说，把堆划分为新生代和老年代有 2 个好处：简化了新对象的分配 (只在新生代分配内存)， 可以更有效的清除不再需要的对象 (即死对象)(新生代和老年代使用不同的 GC 算法)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
      <category term="GC机制" scheme="http://www.lex-zhao.xyz/tags/GC%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>容器技术与虚拟机</title>
    <link href="http://www.lex-zhao.xyz/2017/05/04/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://www.lex-zhao.xyz/2017/05/04/容器技术与虚拟机/</id>
    <published>2017-05-04T06:14:48.000Z</published>
    <updated>2017-05-13T09:29:38.923Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;云计算的本质是集中资源再分配，再分配的过程就是资源的逻辑划分，提供资源抽象的实现方式。其中主要涉及两个方面，资源控制和资源隔离。&lt;/p&gt;
&lt;p&gt;居然一直都无法准确表述镜像的概念，所谓镜像，包括各种打包的Apps、系统使用进程、应用软件、shell以及公用函数库。&lt;/p&gt;
&lt;h1 id=&quot;虚拟机&quot;&gt;&lt;a href=&quot;#虚拟机&quot; class=&quot;headerlink&quot; title=&quot;虚拟机&quot;&gt;&lt;/a&gt;虚拟机&lt;/h1&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.lex-zhao.xyz/tags/Docker/"/>
    
      <category term="虚拟机" scheme="http://www.lex-zhao.xyz/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>春华秋实</title>
    <link href="http://www.lex-zhao.xyz/2017/05/03/%E5%8D%97%E4%BA%AC/"/>
    <id>http://www.lex-zhao.xyz/2017/05/03/南京/</id>
    <published>2017-05-03T10:31:33.000Z</published>
    <updated>2017-05-04T07:18:08.137Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://opeygftv2.bkt.clouddn.com/_DSC1096_%E5%89%AF%E6%9C%AC.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://www.lex-zhao.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="travelog" scheme="http://www.lex-zhao.xyz/tags/travelog/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契堆</title>
    <link href="http://www.lex-zhao.xyz/2017/05/02/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/"/>
    <id>http://www.lex-zhao.xyz/2017/05/02/斐波那契堆/</id>
    <published>2017-05-02T05:10:07.000Z</published>
    <updated>2017-05-04T05:52:54.963Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://opeygftv2.bkt.clouddn.com/829863-20160104171120950-2110922480.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Algorithm" scheme="http://www.lex-zhao.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Latch</title>
    <link href="http://www.lex-zhao.xyz/2017/04/28/Latch/"/>
    <id>http://www.lex-zhao.xyz/2017/04/28/Latch/</id>
    <published>2017-04-28T07:40:52.000Z</published>
    <updated>2017-05-03T09:50:34.498Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;#Latch&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步工具&lt;/strong&gt;类除了最熟悉的阻塞队列之外，还包括&lt;strong&gt;Semaphore、Barrier&lt;/strong&gt;以及&lt;strong&gt;Latch&lt;/strong&gt;。同样，我们也可以创建属于自己的同步工具类。所有的同步工具类都包含了一些特定的结构属性：比如，封装了一些状态，而这些状态将决定执行同步工具类的线程是继续执行还是等待，除此而外，还提供了一些方法对状态进行操作，以及高效的等待同步工具类进入到预期的状态。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>五月任务计划</title>
    <link href="http://www.lex-zhao.xyz/2017/04/28/%E4%BA%94%E6%9C%88%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/"/>
    <id>http://www.lex-zhao.xyz/2017/04/28/五月任务计划/</id>
    <published>2017-04-28T04:59:25.000Z</published>
    <updated>2017-05-03T09:51:02.128Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;###技术目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深入研究&lt;strong&gt;OSGi&lt;/strong&gt;，理解java模块化编程，以及OSGi如何打破类加载机制的双亲委派模型&lt;br&gt; 预期目标：开发一个&lt;strong&gt;Opendaylight&lt;/strong&gt;可用的Bundle，具体功能为获取网络拓普信息并建路&lt;/li&gt;
&lt;li&gt;结合Spring技术内幕一书，研究&lt;strong&gt;Spring&lt;/strong&gt;源码，并以此进一步锤炼java&lt;/li&gt;
&lt;li&gt;尝试编译OpenJDK&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="生活" scheme="http://www.lex-zhao.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="planning" scheme="http://www.lex-zhao.xyz/tags/planning/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="http://www.lex-zhao.xyz/2017/04/28/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://www.lex-zhao.xyz/2017/04/28/synchronized关键字/</id>
    <published>2017-04-28T04:24:43.000Z</published>
    <updated>2017-05-13T09:20:41.810Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;strong&gt;并发编程&lt;/strong&gt;中，多线程同时并发访问的资源叫做&lt;strong&gt;临界资源&lt;/strong&gt;，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机制，以确保在某一时刻，方法内只允许有一个线程。&lt;/p&gt;
&lt;p&gt;采用 synchronized 修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个 monitor (锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
  </entry>
  
</feed>
