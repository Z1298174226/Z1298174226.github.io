<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>倾听枫声</title>
  <subtitle>lex-zhao</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lex-zhao.xyz/"/>
  <updated>2017-09-13T07:49:58.784Z</updated>
  <id>http://www.lex-zhao.xyz/</id>
  
  <author>
    <name>Lex-Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中序遍历的应用</title>
    <link href="http://www.lex-zhao.xyz/2017/09/13/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://www.lex-zhao.xyz/2017/09/13/中序遍历的应用/</id>
    <published>2017-09-13T07:41:51.000Z</published>
    <updated>2017-09-13T07:49:58.784Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;对于二叉树，当涉及到将二叉树转化为有序数组的问题时，应该首先考虑中序遍历和后序遍历。如题：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Algorithm" scheme="http://www.lex-zhao.xyz/tags/Algorithm/"/>
    
      <category term="BST" scheme="http://www.lex-zhao.xyz/tags/BST/"/>
    
      <category term="Leetcode" scheme="http://www.lex-zhao.xyz/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Perfect Square</title>
    <link href="http://www.lex-zhao.xyz/2017/09/07/Perfect-Square/"/>
    <id>http://www.lex-zhao.xyz/2017/09/07/Perfect-Square/</id>
    <published>2017-09-07T05:02:24.000Z</published>
    <updated>2017-09-07T05:02:24.526Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最小高度树</title>
    <link href="http://www.lex-zhao.xyz/2017/09/07/%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"/>
    <id>http://www.lex-zhao.xyz/2017/09/07/最小高度树/</id>
    <published>2017-09-07T02:21:38.000Z</published>
    <updated>2017-09-07T02:37:44.756Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Leetcode" scheme="http://www.lex-zhao.xyz/tags/Leetcode/"/>
    
      <category term="DataStructure" scheme="http://www.lex-zhao.xyz/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>opendaylightplugin学习笔记（一）——StatisticsManager</title>
    <link href="http://www.lex-zhao.xyz/2017/07/28/opendaylightplugin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94StatisticsManager-1/"/>
    <id>http://www.lex-zhao.xyz/2017/07/28/opendaylightplugin学习笔记（一）——StatisticsManager-1/</id>
    <published>2017-07-27T16:00:36.000Z</published>
    <updated>2017-07-28T00:24:47.282Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;@(Opendaylight)[openflowplugin|statistics-manager|beryllium]&lt;/p&gt;
&lt;h4 id=&quot;StatNodeRegistrationImpl&quot;&gt;&lt;a href=&quot;#StatNodeRegistrationImpl&quot; class=&quot;headerlink&quot; title=&quot;StatNodeRegistrationImpl&quot;&gt;&lt;/a&gt;StatNodeRegistrationImpl&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;StaNodeRegistrationImpl在铍版本似乎实现的是之前版本Inventory-Manager中NodeChangeCommit获取节点和端口信息的功能，也就说在铍版本，节点、端口信息获取和存储功能似乎从Inventory-mananger转移到了statistics-manager。有待于进一步证实。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ODL" scheme="http://www.lex-zhao.xyz/tags/ODL/"/>
    
      <category term="SDN" scheme="http://www.lex-zhao.xyz/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>opendaylightplugin学习笔记（二）——TopologyManager</title>
    <link href="http://www.lex-zhao.xyz/2017/07/27/opendaylightplugin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94TopologyManager-1/"/>
    <id>http://www.lex-zhao.xyz/2017/07/27/opendaylightplugin学习笔记（二）——TopologyManager-1/</id>
    <published>2017-07-27T15:57:43.000Z</published>
    <updated>2017-07-27T15:58:50.830Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;topology-manager&lt;/strong&gt;模块是作为&lt;strong&gt;openflowplugin&lt;/strong&gt;的应用层程序（Applications），负责处理operational数据库下network-topology:network-topology数据节点（datastore数据库）的增删改查，例如ODL控制器发现添加一台主机host、新加主机与交换机的link链接等。显示拓扑的前端需要从该数据节点上获取主机或者交换机节点数据才能绘制网络拓扑图，构成拓扑图来源有两方面，一方面是通过LLDP发现的switch设备以及相关link连接，另一外面是通过L2switch的hosttracker模块发现的下挂在switch上的host主机以及相关连接。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ODL" scheme="http://www.lex-zhao.xyz/tags/ODL/"/>
    
      <category term="SDN" scheme="http://www.lex-zhao.xyz/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>Apriori</title>
    <link href="http://www.lex-zhao.xyz/2017/07/16/Apriori/"/>
    <id>http://www.lex-zhao.xyz/2017/07/16/Apriori/</id>
    <published>2017-07-16T08:18:55.000Z</published>
    <updated>2017-07-16T08:19:31.085Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DataMining" scheme="http://www.lex-zhao.xyz/tags/DataMining/"/>
    
      <category term="Algorithm" scheme="http://www.lex-zhao.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>netty之ChannelPipeline和ChannelHandler</title>
    <link href="http://www.lex-zhao.xyz/2017/07/15/netty%E4%B9%8BChannelPipeline%E5%92%8CChannelHandler/"/>
    <id>http://www.lex-zhao.xyz/2017/07/15/netty之ChannelPipeline和ChannelHandler/</id>
    <published>2017-07-15T09:43:09.000Z</published>
    <updated>2017-07-15T10:55:35.918Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Netty的ChannelPipeline和ChannelHandler机制类似于Servlet和Filter过滤器，这类拦截器实际上是职责连模式的一种变形（Netty的三层架构分别为通信业务层，职责链，上层业务），主要是方便事件的拦截和用户业务逻辑的定制。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
      <category term="Netty" scheme="http://www.lex-zhao.xyz/tags/Netty/"/>
    
      <category term="nio" scheme="http://www.lex-zhao.xyz/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>小问题</title>
    <link href="http://www.lex-zhao.xyz/2017/07/11/%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://www.lex-zhao.xyz/2017/07/11/小问题/</id>
    <published>2017-07-11T02:28:37.000Z</published>
    <updated>2017-07-11T02:34:55.661Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天吃饭的时候，问了自己一个问题，java反射到底是个啥，java反射可以实现啥？&lt;br&gt;自己稍微总结一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java反射是在程序运行时，拿到一个类可以得到类的全部属性和方法，拿到一个对象，可以调用对象的全部属性和方法。&lt;/strong&gt;&lt;/p
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>并发锁与条件变量</title>
    <link href="http://www.lex-zhao.xyz/2017/07/09/%E5%B9%B6%E5%8F%91%E9%94%81%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"/>
    <id>http://www.lex-zhao.xyz/2017/07/09/并发锁与条件变量/</id>
    <published>2017-07-09T05:44:44.000Z</published>
    <updated>2017-07-09T06:05:53.790Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;《Java 并发编程实践》一书给出了使用 ReentrantLock 的最佳时机：&lt;/p&gt;
&lt;p&gt;当你需要以下高级特性时，才应该使用：&lt;strong&gt;可定时的&lt;/strong&gt;、&lt;strong&gt;可轮询的&lt;/strong&gt;与&lt;strong&gt;可中断的&lt;/strong&gt;锁获取操作，&lt;strong&gt;公平队列&lt;/strong&gt;，或者&lt;strong&gt;非块结构&lt;/strong&gt;的锁。否则，请使用 synchronized&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互斥同步&lt;/strong&gt;最主要的问题就是进行&lt;strong&gt;线程阻塞&lt;/strong&gt;和&lt;strong&gt;唤醒&lt;/strong&gt;所带来的性能问题，因而这种同步又称为阻塞同步，它属于一种悲观的并发策略，即线程获得的是独占锁。&lt;strong&gt;独占锁&lt;/strong&gt;意味着其他线程只能依靠阻塞来等待线程释放锁。而在 CPU 转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起 CPU 频繁的上下文切换导致效率很低。synchronized 采用的便是这种并发策略。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
      <category term="Concurrent" scheme="http://www.lex-zhao.xyz/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>匈牙利算法</title>
    <link href="http://www.lex-zhao.xyz/2017/07/06/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://www.lex-zhao.xyz/2017/07/06/匈牙利算法/</id>
    <published>2017-07-06T02:41:37.000Z</published>
    <updated>2017-07-17T01:07:46.252Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;二分图的最大匹配和完美匹配本质上还是最大网络流问题。&lt;br&gt;基于深度优先遍历实现&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;br&gt;public class Edmonds {&lt;br&gt;   private boolean[] used;&lt;br&gt;   private int[] girl;&lt;br&gt;   private int[][] path;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Algorithm" scheme="http://www.lex-zhao.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>最大网络流(Ford-Fulkerson)</title>
    <link href="http://www.lex-zhao.xyz/2017/07/05/%E6%9C%80%E5%A4%A7%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://www.lex-zhao.xyz/2017/07/05/最大网络流/</id>
    <published>2017-07-05T10:04:42.000Z</published>
    <updated>2017-07-06T01:38:21.684Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;关于最大网络流算法，网上的教程非常多，可以说形形色色，我个人也稍微做一下总结。&lt;br&gt;网络流算法与背包问题很相似，本质属于线性规划问题。首先需要明确的是容量和流量的两个概念，算法核心思想是从残余图中寻找增广路径直至增广路径不存在（增广路径：一条从源点到宿点的路径，所有的路路径流量为当前最小剩余流量）。穷举试错（DFS、BFS）的过程总是需要“反悔的”，我最开始不假思索想用栈回滚的方式。但Ford-Fulkerson算法很巧妙地利用了方向边，通过反向边的引入实际上实现了回溯。&lt;br&gt;这张图来自谢老师数据挖掘讲义，在此表示感谢。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Algorithm" scheme="http://www.lex-zhao.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>std::function</title>
    <link href="http://www.lex-zhao.xyz/2017/07/04/std-function/"/>
    <id>http://www.lex-zhao.xyz/2017/07/04/std-function/</id>
    <published>2017-07-04T09:34:00.000Z</published>
    <updated>2017-07-06T15:27:53.750Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;类模版&lt;strong&gt;std::function&lt;/strong&gt;是一种通用、多态的函数封装。&lt;strong&gt;std::function&lt;/strong&gt;的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括&lt;strong&gt;普通函数&lt;/strong&gt;、&lt;strong&gt;Lambda表达式&lt;/strong&gt;、&lt;strong&gt;函数指针&lt;/strong&gt;、以及其它函数对象等。&lt;strong&gt;std::function&lt;/strong&gt;对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。&lt;/p&gt;
&lt;p&gt;通常&lt;strong&gt;std::function&lt;/strong&gt;是一个函数对象类，它包装其它任意的函数对象，被包装的函数对象具有类型为T1, …,TN的N个参数，并且返回一个可转换到R类型的值。std::function使用 模板转换构造函数接收被包装的函数对象；特别是，闭包类型可以隐式地转换为std::function。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c++" scheme="http://www.lex-zhao.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>类加载器</title>
    <link href="http://www.lex-zhao.xyz/2017/07/02/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://www.lex-zhao.xyz/2017/07/02/类加载器/</id>
    <published>2017-07-02T11:13:19.000Z</published>
    <updated>2017-07-02T11:20:19.272Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类：&lt;/p&gt;
&lt;p&gt;启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\li(JDK 代表 JDK 的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的java.&lt;em&gt;开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。&lt;br&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>弗洛伊德算法及证明</title>
    <link href="http://www.lex-zhao.xyz/2017/07/02/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E5%8F%8A%E8%AF%81%E6%98%8E/"/>
    <id>http://www.lex-zhao.xyz/2017/07/02/弗洛伊德算法及证明/</id>
    <published>2017-07-02T09:45:38.000Z</published>
    <updated>2017-07-02T11:04:43.542Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;弗洛伊德算法属于动态规划问题，通过插点的方式为加权图多源点间寻求最短路径。算法引入两个二维数组path[][]和dist[][],其中dist[i][j]描述两个节点i和j间的最短路径，path[i][j]用来描述节点i和j之间最短路径所经过的节点。&lt;br&gt;首先，初始化非相邻节点dist为INF，得到初始矩阵S，如图所示。&lt;br&gt;在此鸣谢&lt;a href=&quot;http://www.cnblogs.com/skywang12345所提供的图片&quot;&gt;http://www.cnblogs.com/skywang12345所提供的图片&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://opeygftv2.bkt.clouddn.com/01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Algorithm" scheme="http://www.lex-zhao.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ODL对packet_in消息的处理流程</title>
    <link href="http://www.lex-zhao.xyz/2017/06/03/OpenFlowJava%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.lex-zhao.xyz/2017/06/03/OpenFlowJava处理流程/</id>
    <published>2017-06-03T13:31:04.000Z</published>
    <updated>2017-06-03T13:52:51.695Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;OpenFlowJava对PakcetIn消息的处理流程&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;(1)当交换机遇到无法识别，或者需要上报的数据包（reason字段），通过与OpenFlowJava建立连接，向控制器发送消息。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ODL" scheme="http://www.lex-zhao.xyz/tags/ODL/"/>
    
      <category term="SDN" scheme="http://www.lex-zhao.xyz/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾回收机制(二)——方法区回收</title>
    <link href="http://www.lex-zhao.xyz/2017/05/13/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E4%B8%80-%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.lex-zhao.xyz/2017/05/13/JVM-垃圾回收机制-一-——方法区回收/</id>
    <published>2017-05-13T15:46:01.000Z</published>
    <updated>2017-05-13T16:00:46.228Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;方法区（HotSpot中的永久代）并非没有垃圾回收机制，只是永久代的垃圾回收效率远远低于新生代回收效率。&lt;br&gt;永久代中垃圾回收主要包括两部分：废弃常量和无用的类。回收废弃常量与回收java堆中的对象非常相似，但判断一个类是否是无用的类就比较麻烦，类需要同时满足一下三个条件，才能算是无用的类：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
      <category term="GC机制" scheme="http://www.lex-zhao.xyz/tags/GC%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>（译）JVM 垃圾回收机制(一)——新生代垃圾回收</title>
    <link href="http://www.lex-zhao.xyz/2017/05/10/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.lex-zhao.xyz/2017/05/10/JVM-垃圾回收机制/</id>
    <published>2017-05-10T14:52:51.000Z</published>
    <updated>2017-05-13T12:34:11.962Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;原作者：PATRICK PESCHLOW&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文对原文有改动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单纯从 JVM 的功能考虑，并不需要新生代，完全可以针对整个堆进行操作。新生代存在的唯一理由是优化垃圾回收 (GC) 的性能。更具体说，把堆划分为新生代和老年代有 2 个好处：简化了新对象的分配 (只在新生代分配内存)， 可以更有效的清除不再需要的对象 (即死对象)(新生代和老年代使用不同的 GC 算法)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://www.lex-zhao.xyz/tags/java/"/>
    
      <category term="GC机制" scheme="http://www.lex-zhao.xyz/tags/GC%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>容器技术与虚拟机</title>
    <link href="http://www.lex-zhao.xyz/2017/05/04/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://www.lex-zhao.xyz/2017/05/04/容器技术与虚拟机/</id>
    <published>2017-05-04T06:14:48.000Z</published>
    <updated>2017-05-13T09:29:38.923Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;云计算的本质是集中资源再分配，再分配的过程就是资源的逻辑划分，提供资源抽象的实现方式。其中主要涉及两个方面，资源控制和资源隔离。&lt;/p&gt;
&lt;p&gt;居然一直都无法准确表述镜像的概念，所谓镜像，包括各种打包的Apps、系统使用进程、应用软件、shell以及公用函数库。&lt;/p&gt;
&lt;h1 id=&quot;虚拟机&quot;&gt;&lt;a href=&quot;#虚拟机&quot; class=&quot;headerlink&quot; title=&quot;虚拟机&quot;&gt;&lt;/a&gt;虚拟机&lt;/h1&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.lex-zhao.xyz/tags/Docker/"/>
    
      <category term="虚拟机" scheme="http://www.lex-zhao.xyz/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>春华秋实</title>
    <link href="http://www.lex-zhao.xyz/2017/05/03/%E5%8D%97%E4%BA%AC/"/>
    <id>http://www.lex-zhao.xyz/2017/05/03/南京/</id>
    <published>2017-05-03T10:31:33.000Z</published>
    <updated>2017-05-04T07:18:08.137Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://opeygftv2.bkt.clouddn.com/_DSC1096_%E5%89%AF%E6%9C%AC.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://www.lex-zhao.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="travelog" scheme="http://www.lex-zhao.xyz/tags/travelog/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契堆</title>
    <link href="http://www.lex-zhao.xyz/2017/05/02/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/"/>
    <id>http://www.lex-zhao.xyz/2017/05/02/斐波那契堆/</id>
    <published>2017-05-02T05:10:07.000Z</published>
    <updated>2017-05-04T05:52:54.963Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://opeygftv2.bkt.clouddn.com/829863-20160104171120950-2110922480.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.lex-zhao.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Algorithm" scheme="http://www.lex-zhao.xyz/tags/Algorithm/"/>
    
  </entry>
  
</feed>
