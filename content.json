{"meta":{"title":"倾听枫声","subtitle":"lex-zhao","description":"生活的理想是为了理想的生活","author":"Lex-Zhao","url":"http://www.lex-zhao.xyz"},"pages":[{"title":"博主标签","date":"2017-05-02T07:11:37.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/about/index.html","keywords":"","text":"西电低配金城武摄影通信码农汪ALGORITHM机器人爱好者Java后台专注软件定义网络重度强迫症患者非完美主义者"},{"title":"categories","date":"2017-05-03T02:49:12.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/categories/index.html","keywords":"","text":""},{"title":"Tagcloud","date":"2017-05-03T01:46:02.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/tags/index.html","keywords":"","text":""},{"title":"任务书","date":"2017-04-28T06:57:47.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/任务书/index.html","keywords":"","text":""}],"posts":[{"title":"JVM 垃圾回收机制(二)——方法区回收","slug":"JVM-垃圾回收机制-一-——方法区回收","date":"2017-05-13T15:46:01.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/2017/05/13/JVM-垃圾回收机制-一-——方法区回收/","text":"方法区（HotSpot中的永久代）并非没有垃圾回收机制，只是永久代的垃圾回收效率远远低于新生代回收效率。永久代中垃圾回收主要包括两部分：废弃常量和无用的类。回收废弃常量与回收java堆中的对象非常相似，但判断一个类是否是无用的类就比较麻烦，类需要同时满足一下三个条件，才能算是无用的类： 该类所有的实例都已经被回收，即java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP记忆OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代永远不会溢出。 注：可以使用-verbose：class以及-XX:_TraceClassLoading、-XX:TraceClassUnLoading查看类加载和卸载信息"},{"title":"（译）JVM 垃圾回收机制(一)——新生代垃圾回收","slug":"JVM-垃圾回收机制","date":"2017-05-10T14:52:51.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/2017/05/10/JVM-垃圾回收机制/","text":"原作者：PATRICK PESCHLOW 本文对原文有改动 单纯从 JVM 的功能考虑，并不需要新生代，完全可以针对整个堆进行操作。新生代存在的唯一理由是优化垃圾回收 (GC) 的性能。更具体说，把堆划分为新生代和老年代有 2 个好处：简化了新对象的分配 (只在新生代分配内存)， 可以更有效的清除不再需要的对象 (即死对象)(新生代和老年代使用不同的 GC 算法)通过广泛研究面向对象实现的应用，发现一个共同特点：很多对象的生存时间都很短。同时研究发现，新生对象很少引用生存时间长的对象。结合这 2 个特点，很明显 GC 会频繁访问新生对象，例如在堆中一个单独的区域，称之为新生代。在新生代中，GC 可以快速标记回收” 死对象”，而不需要扫描整个 Heap 中的存活一段时间的” 老对象”。 SUN/Oracle 的 HotSpot JVM 又把新生代进一步划分为 3 个区域：一个相对大点的区域，称为“伊甸园区 (Eden)”；两个相对小点的区域称为“From 幸存区 (survivor)” 和“To 幸存区 (survivor)”。按照规定，新对象会首先分配在 Eden 中 (如果新对象过大，会直接分配在老年代中)。在 GC 中，Eden 中的对象会被移动到 survivor 中，直至对象满足一定的年纪 (定义为熬过 GC 的次数)，会被移动到老年代(默认为15岁)。 基于大多数新生对象都会在 GC 中被收回的假设。新生代的 GC 使用复制算法。在 GC 前 To 幸存区 (survivor) 保持清空，对象保存在 Eden 和 From 幸存区 (survivor) 中，GC 运行时，Eden 中的幸存对象被复制到 To 幸存区 (survivor)。针对 From 幸存区 (survivor) 中的幸存对象，会考虑对象年龄，如果年龄没达到阀值 (tenuring threshold)，对象会被复制到 To 幸存区 (survivor)。如果达到阀值对象被复制到老年代。复制阶段完成后，Eden 和 From 幸存区中只保存死对象，可以视为清空。如果在Survivor空间中相同年龄所有对象大小的总和超过了Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。上图演示 GC 过程，黄色表示死对象，绿色表示剩余空间，红色表示幸存对象 总结一下，对象一般出生在 Eden 区，年轻代 GC 过程中，对象在 2 个幸存区之间移动，如果对象存活到适当的年龄，会被移动到老年代。当对象在老年代死亡时，就需要更高级别的 GC，更重量级的 GC 算法 (复制算法不适用于老年代，因为没有多余的空间用于复制) 现在应该能理解为什么新生代大小非常重要了 (译者，有另外一种说法：新生代大小并不重要，影响 GC 的因素主要是幸存对象的数量)，如果新生代过小，会导致新生对象很快就晋升到老年代中，在老年代中对象很难被回收。如果新生代过大，会发生过多的复制过程。我们需要找到一个合适大小，不幸的是，要想获得一个合适的大小，只能通过不断的测试调优。这就需要 JVM 参数了 -XX:NewSize and -XX:MaxNewSize 就像可以通过参数 (-Xms and -Xmx) 指定堆大小一样，可以通过参数指定新生代大小。设置 XX:MaxNewSize 参数时，应该考虑到新生代只是整个堆的一部分，新生代设置的越大，老年代区域就会减少。一般不允许新生代比老年代还大，因为要考虑 GC 时最坏情况，所有对象都晋升到老年代。(译者: 会发生 OOM 错误) -XX:MaxNewSize 最大可以设置为 - Xmx/2。 考虑性能，一般会通过参数 -XX:NewSize 设置新生代初始大小。如果知道新生代初始分配的对象大小 (经过监控)，这样设置会有帮助，可以节省新生代自动扩展的消耗。 -XX:NewRatio 可以设置新生代和老年代的相对大小。这种方式的优点是新生代大小会随着整个堆大小动态扩展。参数 -XX:NewRatio 设置老年代与新生代的比例。例如 -XX:NewRatio=3 指定老年代 / 新生代为 3/1。 老年代占堆大小的 3/4，新生代占 1/4 。 如果针对新生代，同时定义绝对值和相对值，绝对值将起作用。下面例子： $ java -XX:NewSize=32m -XX:MaxNewSize=512m -XX:NewRatio=3 MyApp 以上设置，JVM 会尝试为新生代分配四分之一的堆大小，但不会小于 32MB 或大于 521MB 在设置新生代大小问题上，使用绝对值还是相对值，不存在通用准则 。如果了解应用的内存使用情况， 设置固定大小的堆和新生代更有利，当然也可以设置相对值。如果对应用的内存使用一无所知，正确的做法是不要设置任何参数，如果应用运行良好。很好，我们不用做任何额外动作。如果遇到性能或 OutOfMemoryErrors，在调优之前，首先需要进行一系列有目的的监控测试，缩小问题的根源。 -XX:SurvivorRatio 参数 -XX:SurvivorRatio 与 -XX:NewRatio 类似，作用于新生代内部区域。-XX:SurvivorRatio 指定伊甸园区 (Eden) 与幸存区大小比例。 例如， -XX:SurvivorRatio=10 表示伊甸园区 (Eden) 是 幸存区 To 大小的 10 倍 (也是幸存区 From 的 10 倍)。 所以， 伊甸园区 (Eden) 占新生代大小的 10/12， 幸存区 From 和幸存区 To 每个占新生代的 1/12 。 注意， 两个幸存区永远是一样大的。 设定幸存区大小有什么作用? 假设幸存区相对伊甸园区 (Eden) 太小， 相应新生对象的伊甸园区 (Eden) 永远很大空间， 我们当然希望， 如果这些对象在 GC 时全部被回收， 伊甸园区 (Eden) 被清空， 一切正常。 然而， 如果有一部分对象在 GC 中幸存下来， 幸存区只有很少空间容纳这些对象。 结果大部分幸存对象在一次 GC 后，就会被转移到老年代 ， 这并不是我们希望的。 考虑相反情况， 假设幸存区相对伊甸园区 (Eden) 太大， 当然有足够的空间，容纳 GC 后的幸存对象。 但是过小的伊甸园区 (Eden)， 意味着空间将越快耗尽，增加新生代 GC 次数，这是不可接受的。 总之， 我们希望最小化短命对象晋升到老年代的数量，同时也希望最小化新生代 GC 的次数和持续时间。 我们需要找到针对当前应用的折中方案， 寻找适合方案的起点是 了解当前应用中对象的年龄分布情况。 -XX:+PrintTenuringDistribution 参数 -XX:+PrintTenuringDistribution 指定 JVM 在每次新生代 GC 时，输出幸存区中对象的年龄分布。例如: Desired survivor size 75497472 bytes， new threshold 15 (max 15)age 1: 19321624 bytes， 19321624 totalage 2: 79376 bytes， 19401000 totalage 3: 2904256 bytes， 22305256 total第一行说明幸存区 To 大小为 75 MB。 也有关于老年代阀值 (tenuring threshold) 的信息， 老年代阀值，意思是对象从新生代移动到老年代之前，经过几次 GC(即， 对象晋升前的最大年龄)。 上例中， 老年代阀值为 15， 最大也是 15。 之后行表示，对于小于老年代阀值的每一个对象年龄，本年龄中对象所占字节 (如果当前年龄没有对象， 这一行会忽略)。 上例中， 一次 GC 后幸存对象大约 19 MB， 两次 GC 后幸存对象大约 79 KB，三次 GC 后幸存对象大约 3 MB 。 每行结尾，显示直到本年龄全部对象大小。 所以， 最后一行的 total 表示幸存区 To 总共被占用 22 MB 。 幸存区 To 总大小为 75 MB ， 当前老年代阀值为 15，可以断定在本次 GC 中，没有对象会移动到老年代。现在假设下一次 GC 输出为： Desired survivor size 75497472 bytes， new threshold 2 (max 15)age 1: 68407384 bytes， 68407384 totalage 2: 12494576 bytes， 80901960 totalage 3: 79376 bytes， 80981336 totalage 4: 2904256 bytes， 83885592 total对比前一次老年代分布。明显的， 年龄 2 和年龄 3 的对象还保持在幸存区中，因为我们看到年龄 3 和 4 的对象大小与前一次年龄 2 和 3 的相同。同时发现幸存区中， 有一部分对象已经被回收， 因为本次年龄 2 的对象大小为 12MB ，而前一次年龄 1 的对象大小为 19 MB。最后可以看到最近的 GC 中，有 68 MB 新对象，从伊甸园区移动到幸存区。 注意， 本次 GC 幸存区占用总大小 84 MB - 大于 75 MB。 结果， JVM 把老年代阀值从 15 降低到 2，在下次 GC 时，一部分对象会强制离开幸存区，这些对象可能会被回收 (如果他们刚好死亡) 或移动到老年代。 -XX:InitialTenuringThreshold， -XX:MaxTenuringThreshold and -XX:TargetSurvivorRatio 参数 -XX:+PrintTenuringDistribution 输出中的部分值可以通过其它参数控制。通过 -XX:InitialTenuringThreshold 和 -XX:MaxTenuringThreshold 可以设定老年代阀值的初始值和最大值。另外， 可以通过参数 -XX:TargetSurvivorRatio 设定幸存区的目标使用率。 例如， -XX:MaxTenuringThreshold=10 -XX:TargetSurvivorRatio=90 设定老年代阀值的上限为 10， 幸存区空间目标使用率为 90%。 有多种方式， 设置新生代行为，没有通用准则。我们必须清楚以下 2 中情况： 如果从年龄分布中发现，有很多对象的年龄持续增长，在到达老年代阀值之前。这表示 -XX:MaxTenuringThreshold 设置过大 如果 -XX:MaxTenuringThreshold 的值大于 1，但是很多对象年龄从未大于 1。应该看下幸存区的目标使用率。如果幸存区使用率从未到达，这表示对象都被 GC 回收，这正是我们想要的。 如果幸存区使用率经常达到，有些年龄超过 1 的对象被移动到老年代中。这种情况，可以尝试调整幸存区大小或目标使用率。-XX:+NeverTenure and -XX:+AlwaysTenure 最后，我们介绍 2 个颇为少见的参数，对应 2 种极端的新生代 GC 情况。设置参数 -XX:+NeverTenure，对象永远不会晋升到老年代。当我们确定不需要老年代时，可以这样设置。这样设置风险很大， 并且会浪费至少一半的堆内存。相反设置参数 -XX:+AlwaysTenure，表示没有幸存区，所有对象在第一次 GC 时，会晋升到老年代。 没有合理的场景使用这个参数。可以在测试环境中，看下这样设置会发生什么有趣的事。但是并不推荐使用这些参数。 结论 适当的配置新生代非常重要，有相当多的参数可以设置新生代。然而，单独调整新生代，而不考虑老年代是不可能优化成功的。当调整堆和 GC 设置时，我们总是应该同时考虑新生代和老年代。"},{"title":"容器技术与虚拟机","slug":"容器技术与虚拟机","date":"2017-05-04T06:14:48.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/2017/05/04/容器技术与虚拟机/","text":"云计算的本质是集中资源再分配，再分配的过程就是资源的逻辑划分，提供资源抽象的实现方式。其中主要涉及两个方面，资源控制和资源隔离。 居然一直都无法准确表述镜像的概念，所谓镜像，包括各种打包的Apps、系统使用进程、应用软件、shell以及公用函数库。 虚拟机 虚拟机的Guest OS即为虚拟机安装的操作系统，它是一个完整操作系统内核；虚拟机的Hypervisor层可以简单理解为一个硬件虚拟化平台(VMW、VirtualBox)，它在Host OS是以内核态的驱动存在的。虚拟机实现资源隔离的方法是利用独立的OS，并利用Hypervisor虚拟化CPU、内存、IO设备等实现的。 为了虚拟CPU，Hypervisor会为每个虚拟的CPU创建一个数据结构，模拟CPU的全部寄存器的值，在适当的时候跟踪并修改这些值。需要指出的是在大多数情况下，虚拟机软件代码是直接跑在硬件上的，而不需要Hypervisor介入。只有在一些权限高的请求下，Guest OS需要运行内核态修改CPU的寄存器数据，Hypervisor会介入，修改并维护虚拟的CPU状态。 Hypervisor虚拟化内存的方法是创建一个shadow page table。正常的情况下，一个page table可以用来实现从虚拟内存到物理内存的翻译。在虚拟化的情况下，由于所谓的物理内存仍然是虚拟的，因此shadow page table就要做到：虚拟内存-&gt;虚拟的物理内存-&gt;真正的物理内存。 对于IO设备虚拟化，当Hypervisor接到page fault，并发现实际上虚拟的物理内存地址对应的是一个I/O设备，Hypervisor就用软件模拟这个设备的工作情况，并返回。比如当CPU想要写磁盘时，Hypervisor就把相应的数据写到一个host OS的文件上，这个文件实际上就模拟了虚拟的磁盘。 Docker容器技术的出现远远早于Docker，Docker只是提供了一个能够方便管理容器的工具并为其提供了标准。Docker相当于把应用以及应用所依赖的环境完整打成一个包，这个包不管拿到哪里都能够原生运行。 docker Engine可以简单看成对Linux的NameSpace、Cgroup、镜像管理文件系统操作的封装。docker并没有和虚拟机一样利用一个完全独立的Guest OS实现环境隔离，它利用的是目前Linux内核本身支持的容器方式,主要是Namespace和CGroup来实现资源和环境隔离。其中namespace实现系统环境的隔离，Cgroup实现资源限制，而利用镜像实现根目录环境的隔离。 通过docker和虚拟机实现原理的比较，我们大致可以得出一些结论： docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有优势。在IO设备虚拟化上，docker的镜像管理有多种方案，比如利用Aufs文件系统或者Device Mapper实现docker的文件管理，各种实现方案的效率略有不同。 docker利用的是宿主机的内核，而不需要Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。我们知道，引导、加载操作系统内核是一个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统，则省略了这个过程，因此新建一个docker容器只需要几秒钟。另外，现代操作系统是复杂的系统，在一台物理机上新增加一个操作系统的资源开销是比较大的，因此，docker对比虚拟机在资源消耗上也占有比较大的优势。事实上，在一台物理机上我们可以很容易建立成百上千的容器，而只能建立几个虚拟机。 CGroup与Namespace CGroup将一组进程放在一个控制组里，通过给这个控制组分配指定的可用资源，达到控制这一组进程可用资源的目的。 NamespaceNamespace是将内核的全局资源做封装，使得每个Namespace都有一份独立的资源，因此不同的进程在各自的Namespace内对同一种资源的实用不会相互干扰。Linux总共实现了6种Namespace： IPC：隔离System VIPC和POSIX消息队列 Network ： 隔离网络资源 Mount 隔离文件系统挂载点 PID ：隔离进程ID UTS ：隔离主机名和域名 User ：隔离用户ID和组ID 容器 = CGroup + NameSpace+rootfs+容器引擎 rootfs：文件隔离控制容器引擎： 生命周期控制 Docker与虚拟机的优劣 虚拟机 由于虚拟机镜像必须依赖于Guest OS这一庞大的内核，因此十分臃肿，无法在一台物理主机上大量建立 由于虚拟机启动前必须先启动Guest OS,因此，创建和启动的时间开销大 使用虚拟资源会存在资源损耗 部署密度小 Docker优势 镜像体积小，只包括apps以及所依赖的环境，没有内核 创建启动时间开销小 没有Guest OS和hypervisor，无额外资源开销，资源控制粒度小，部署密度大 使用的是真实的物力资源，不存在资源损耗 Docker劣势docker的劣势 资源隔离方面不如虚拟机，docker是利用cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源。 安全性问题。docker目前并不能分辨具体执行指令的用户，只要一个用户拥有执行docker的权限，那么他就可以对docker的容器进行所有操作，不管该容器是否是由该用户创建。比如A和B都拥有执行docker的权限，由于docker的server端并不会具体判断docker cline是由哪个用户发起的，A可以删除B创建的容器，存在一定的安全风险。 docker目前还在版本的快速更新中，细节功能调整比较大。一些核心模块依赖于高版本内核，存在版本兼容问题"},{"title":"春华秋实","slug":"南京","date":"2017-05-03T10:31:33.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/2017/05/03/南京/","text":""},{"title":"斐波那契堆","slug":"斐波那契堆","date":"2017-05-02T05:10:07.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/2017/05/02/斐波那契堆/","text":"一个斐波那契堆具有如下性质： 堆有一组有序树组成，但是堆中的树不一定是二项树 斐波那契堆中的树之间是无序的（二项堆中的树是按照其包含的二项树的度数排序的） 堆中每个节点的数据结构包含如下域： 指向其父节点的指针域 指向其任意一个孩子的指针域 任意一个节点x的所有孩子被链接在一个双向链表环形链表中 节点x中保存有它的孩子的数目degree 节点x中存在一个域mark，用于表示自从x上一次称为另一个节点的子女以来，它是否失掉了一个孩子，TRUE表示是失去了，FALSE表示未失去斐波那契堆中的所有树的树根被保存在一个链表即根表中对于一个斐波那契堆，min[H]保存了具有最小节点值的根节点在计算机科学中，斐波那契堆是由树的集合所组成的堆数据结构。它比二项堆的平摊运行时间更好。斐波那契堆的名字来自于斐波那契数列，这些数列被用来做运行时间分析。 求最小值(find-mininum), 插入(insert), 降低元素值(decrease-key)和合并(merge/union)可以在常数平摊时间内完成。删除(delete)和删除最小值(delete minimun)可以在O(log n)平摊时间内完成。 在优先队列(priority queues)中使用斐波那契堆可以提升重要算法的渐进运行时间，例如Dijkstra算法，该算法用来计算一个图中两个结点的最短的距离。 斐波那契堆是由一些树的集合所组成，其中每一棵树都满足最小堆(minimum-heap)的属性，也就是说树中每个子结点的值都大于或者等于其父结点的值，而最小值则处在根结点上。 与二项堆不同，斐波那契堆中的树更加灵活，没有规定的形状，在极端情况下，堆中每个元素都是一棵单独的树。这种灵活性使得一些操作可以以“偷懒”的方式来执行，而“剩下”的工作将推迟到后面的操作中来完成。比如堆的合并仅仅将由树所组成的链表链接起来，而降低元素值(decrease key)有时直接从父结点中剪断而形成一棵新树。 下面给出斐波那契堆中关键的量值： degree[x]:degree[x]: 表示结点x的子结点个数 mark[x]:mark[x]: 一个结点是否被marked了（当执行decrease key操作时会用到） t(H):t(H): 表示堆中树的个数 m(H):m(H): 表示被marked的结点数量 Φ(H)=t(H)+2m(H):Φ(H)=t(H)+2m(H): 表示势函数 如下图所示：从图中可以看出，一共有5棵树，即t(H)=5t(H)=5，最小值的指针指向元素值为3的根结点，在这棵包含最小值的树中，根结点有3个子结点，所以其degree等于3，整个斐波那契堆用 H 来表示。其中黑色表示被marked了，灰色表示没有被marked，所以m(H)=3m(H)=3，势函数 Φ(H)=t(H)+2m(H)=5+2∗3=11Φ(H)=t(H)+2m(H)=5+2∗3=11 Make-Fibonacci-Heap() n[H] := 0 min[H] := NIL return H Fibonacci-Heap-Minimum(H) return min[H] Fibonacci-Heap-Link(H,y,x) remove y from the root list of H make y a child of x degree[x] := degree[x] + 1 mark[y] := FALSE CONSOLIDATE(H) for i:=0 to D(n[H]) Do A[i] := NIL for each node w in the root list of H do x:= w d:= degree[x] while A[d] NIL do y:=A[d] if key[x]>key[y] then exchange xy Fibonacci-Heap-Link(H, y, x) A[d]:=NIL d:=d+1 A[d]:=x min[H]:=NIL for i:=0 to D(n[H]) do if A[i] NIL then add A[i] to the root list of H if min[H] = NIL or key[A[i]]"},{"title":"Latch","slug":"Latch","date":"2017-04-28T07:40:52.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/2017/04/28/Latch/","text":"#Latch 同步工具类除了最熟悉的阻塞队列之外，还包括Semaphore、Barrier以及Latch。同样，我们也可以创建属于自己的同步工具类。所有的同步工具类都包含了一些特定的结构属性：比如，封装了一些状态，而这些状态将决定执行同步工具类的线程是继续执行还是等待，除此而外，还提供了一些方法对状态进行操作，以及高效的等待同步工具类进入到预期的状态。闭锁最形象的比喻是一扇Gate，在闭锁到达结束状态之前，这扇门始终处于关闭的状态，任何线程都无法通过。而当闭锁到达结束状态，这扇门将打开，进而允许所有的线程通过。一旦闭锁达到结束状态，这扇门将保持打开的状态，不会再关闭。换句话说，闭锁的作用是保持某些活动直到其他活动都完成才继续执行。举个例子，我们都知道并发在某些情况下，可以极大地提升工作效率，缩短程序的运行时间，那么我们该如何去获取并发程序准确的运行时间，即在所有线程全部就绪的时刻启动时间，而在所有线程全部结束的时刻终止时间。Latch可以做到，看下面程序。 public class TestHarness { public static String timeTask(int nThreads,final Runnable[] tasks) throws InterruptedException{ final CountDownLatch startGate=new CountDownLatch(1); final CountDownLatch endGate=new CountDownLatch(nThreads); for(Runnable task:tasks){ Thread t=new Thread(){ public void run(){ try{ startGate.await(); try{ task.run(); }finally{ //每个线程最终最后执行将endGate减1 endGate.countDown(); } }catch(InterruptedException e){ } } }; t.start(); } long startTime=System.nanoTime(); startGate.countDown(); endGate.await(); long endTime=System.nanoTime(); return \"Time: \"+(endTime-startTime)+\"ns\"; } 由于startGate被设置为等待 startGate.await(); 因此每个线程首先要做的工作就是在启动门上等待，直到所有的线程全部就绪。并且，我们在为每个线程装载任务时 finally{endGate.countDown();} 保证没个线程最终都会执行使得endGate减1的任务 startGate.countDown(); 注意startGate的初值为1，因此调用countDown方法后，门打开，此时线程开始执行 endGate.await(); endGate此时关闭，要做的工作就是等待且为零的时刻，然后打开 如果没用使用Latch工具而去获取并行线程的运行时间，线程在被创建之后将立即执行，显然，先启动的线程势必会领先于后启动的线程，并且活跃线程的数量会随着时间的推移而慢慢减少或者增加，竞争程度也将发生变化。有了这个工具，我们今后在编写并发程序是，只需要调用timeTasks函数，并向其传递任务参数，就可以获取并发时间了。"},{"title":"五月任务计划","slug":"五月任务计划","date":"2017-04-28T04:59:25.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/2017/04/28/五月任务计划/","text":"###技术目标 深入研究OSGi，理解java模块化编程，以及OSGi如何打破类加载机制的双亲委派模型 预期目标：开发一个Opendaylight可用的Bundle，具体功能为获取网络拓普信息并建路 结合Spring技术内幕一书，研究Spring源码，并以此进一步锤炼java 尝试编译OpenJDK ###论文目标 5号之间将论文搞定 15号之前完成论文翻译工作 ####出行 争取在月内和女神实现厦门行"},{"title":"synchronized关键字","slug":"synchronized关键字","date":"2017-04-28T04:24:43.000Z","comments":true,"permalink":"http://www.lex-zhao.xyz/2017/04/28/synchronized关键字/","text":"在并发编程中，多线程同时并发访问的资源叫做临界资源，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机制，以确保在某一时刻，方法内只允许有一个线程。 采用 synchronized 修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个 monitor (锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。这里就使用同步机制获取互斥锁的情况，进行几点说明： 1、如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。 2、类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的 synchronized 同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问 synchronized 同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。 3、访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。 4、持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非 synchronized 代码。当一个线程 A 持有一个对象级别锁（即进入了 synchronized 修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程 B 有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用 synchronized 修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让 A 线程运行，A 线程继续持有对象级别锁，当 A 线程退出同步代码时（即释放了对象级别锁），如果 B 线程此时再运行，便会获得该对象级别锁，从而执行 synchronized 中的代码。 5、持有对象级别锁的线程会让其他线程阻塞在所有的 synchronized 代码外。例如，在一个类中有三个synchronized 方法 a，b，c，当线程 A 正在执行一个实例对象 M 中的方法 a 时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象 M）中的代码时，便会在所有的 synchronized 方法处阻塞，即在方法 a，b，c 处都要被阻塞，等线程 A 释放掉对象级别锁时，其他的线程才可以去执行方法 a，b 或者 c 中的代码，从而获得该对象级别锁。 6、使用 synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj 为对象的引用，如果获取了 obj 对象上的对象级别锁，在并发访问 obj 对象时时，便会在其 synchronized 代码处阻塞等待，直到获取到该 obj对象的对象级别锁。当 obj 为 this 时，便是获取当前对象的对象级别锁。 7、类级别锁被特定类的所有示例共享，它用于控制对 static 成员变量以及 static 方法的并发访问。具体用法与对象级别锁相似。 8、互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized 关键字经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加 1，相应地，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁便被释放了。由于 synchronized 同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。"}]}