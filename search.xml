<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[匈牙利算法]]></title>
      <url>/2017/07/06/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>二分图的最大匹配和完美匹配本质上还是最大网络流问题。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最大网络流(Ford-Fulkerson)]]></title>
      <url>/2017/07/05/%E6%9C%80%E5%A4%A7%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>关于最大网络流算法，网上的教程非常多，可以说形形色色，我个人也稍微做一下总结。<br>网络流算法与背包问题很相似，本质属于线性规划问题。首先需要明确的是容量和流量的两个概念，算法核心思想是从残余图中寻找增广路径直至增广路径不存在（增广路径：一条从源点到宿点的路径，所有的路路径流量为当前最小剩余流量）。穷举试错（DFS、BFS）的过程总是需要“反悔的”，我最开始不假思索想用栈回滚的方式。但Ford-Fulkerson算法很巧妙地利用了方向边，通过反向边的引入实际上实现了回溯。<br>这张图来自谢老师数据挖掘讲义，在此表示感谢。<br><a id="more"></a><br><img src="http://opeygftv2.bkt.clouddn.com/Max_flow.JPG" alt=""><br>Java实现</p>
<p><pre><code><br>public class FordFulkersonDemo {<br>    private int[][] Graph;<br>    private int[][] f;<br>    private int[][] r;<br>    private int[] parent;<br>    private int source;<br>    private int terminal;</code></pre></p>
<pre><code>public FordFulkersonDemo(int Num){
    Graph = new int[Num][Num];
    f = new int[Num][Num];
    r = new int[Num][Num];
    parent = new int[Num];
}
public FordFulkersonDemo(In in){
    this(in.readInt());
    for(int i = 0; i &lt; parent.length; i++){
        for(int j = 0; j &lt; parent.length; j++){
            Graph[i][j] = in.readInt();
        }
    }
    source = in.readInt();
    terminal = in.readInt();
}
private void initialization(){
    for(int i = 0; i &lt; parent.length; i++){
        Arrays.fill(f[i], 0);
    }
}

private int[][] residualNetwork(int[][] graph,int[][] f){
    int[][] r = new int[parent.length][parent.length];
    for(int i = 0; i &lt; parent.length; i++){
        for(int j = 0; j &lt; parent.length; j++){
            r[i][j] = graph[i][j] - f[i][j];
        }
    }
    return r;
}

private int argumentPath(int[][] r,int s,int t){
    Arrays.fill(parent, -1);
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    int maxFlow = Integer.MAX_VALUE;
    q.add(s);
    parent[s] = s;
    while(!q.isEmpty()){
        int v = q.poll();
        if(v == t){
            while(v != s){
                if(maxFlow &gt; r[parent[v]][v])
                    maxFlow = r[parent[v]][v];
                v = parent[v];
            }
            break;
        }
            for(int i = 0 ; i &lt; parent.length; i++){
                if(i != v &amp;&amp; parent[i] == -1 &amp;&amp; r[v][i] &gt; 0){
                    parent[i] = v;
                    q.add(i);
                }
            }
        }

    if(parent[t] == -1){
        maxFlow = -1;
    }
    return maxFlow;
}

public int run(){
    int sum = 0;
    initialization();
    r = residualNetwork(Graph,f);
    int result = argumentPath(r,source,terminal);
    //int cur = terminal;
    while(result != -1){
        int cur = terminal;
        while(cur != source){
            f[parent[cur]][cur] += result;
            f[cur][parent[cur]] = -f[parent[cur]][cur];
            r[parent[cur]][cur] -= result;
            r[cur][parent[cur]] += result;
            cur = parent[cur];
        }
            sum += result;
        //    r = residualNetwork(Graph,f);
            result = argumentPath(r,source,terminal);
    }
    return sum;
}

public static void main(String[] args){
    In in = new In(args[0]);
    FordFulkersonDemo ford = new FordFulkersonDemo(in);
    System.out.println(ford.run());
}
</code></pre><p>}</p>
<p><br>在此验证一下程序的效果：<br><img src="http://opeygftv2.bkt.clouddn.com/MaxFlowDemo1.JPG" alt=""><br>程序运行后结果</p>
<p><img src="http://opeygftv2.bkt.clouddn.com/result.JPG" alt=""><br><img src="http://opeygftv2.bkt.clouddn.com/MaxFlowDemo2.JPG" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[std::function]]></title>
      <url>/2017/07/04/std-function/</url>
      <content type="html"><![CDATA[<p>类模版<strong>std::function</strong>是一种通用、多态的函数封装。<strong>std::function</strong>的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括<strong>普通函数</strong>、<strong>Lambda表达式</strong>、<strong>函数指针</strong>、以及其它函数对象等。<strong>std::function</strong>对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。</p>
<p>通常<strong>std::function</strong>是一个函数对象类，它包装其它任意的函数对象，被包装的函数对象具有类型为T1, …,TN的N个参数，并且返回一个可转换到R类型的值。std::function使用 模板转换构造函数接收被包装的函数对象；特别是，闭包类型可以隐式地转换为std::function。<br><a id="more"></a><br>最简单的理解就是：</p>
<p><strong>通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象；让我们不再纠结那么多的可调用实体。一切变的简单粗暴</strong>。</p>
<pre>
<code>
#include <functional>
#include <iostream>
using namespace std;

std::function< int(int)> Functional;

// 普通函数
int TestFunc(int a)
{
    return a;
}

// Lambda表达式
auto lambda = [](int a)->int { return a; };

// 仿函数(functor)
class Functor
{
public:
    int operator()(int a)
    {
        return a;
    }
};

// 1.类成员函数
// 2.类静态函数
class TestClass
{
public:
    int ClassMember(int a) { return a; }
    static int StaticMember(int a) { return a; }
};

int main()
{
    // 普通函数
    Functional = TestFunc;
    int result = Functional(10);
    cout << "普通函数：" << result << endl;

    // Lambda表达式
    Functional = lambda;
    result = Functional(20);
    cout << "Lambda表达式：" << result << endl;

    // 仿函数
    Functor testFunctor;
    Functional = testFunctor;
    result = Functional(30);
    cout << "仿函数：" << result << endl;

    // 类成员函数
    TestClass testObj;
    Functional = std::bind(&TestClass::ClassMember, testObj, std::placeholders::_1);
    result = Functional(40);
    cout << "类成员函数：" << result << endl;

    // 类静态函数
    Functional = TestClass::StaticMember;
    result = Functional(50);
    cout << "类静态函数：" << result << endl;
    system("pause");
    return 0;
}
</iostream></functional></code></pre>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[类加载器]]></title>
      <url>/2017/07/02/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<p>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\li(JDK 代表 JDK 的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的java.<em>开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。<br><a id="more"></a><br>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如javax.</em>开头的类），开发者可以直接使用扩展类加载器。</p>
<p>应用程序类加载器：Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<br>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为 JVM 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的 ClassLoader，便可以做到如下几点：</p>
<p>*在执行非置信代码之前，自动验证数字签名。</p>
<p>*动态地创建符合用户特定需要的定制化构建类。</p>
<p>*从特定的场所取得 java class，例如数据库中和网络中。</p>
<p>事实上当使用 Applet 的时候，就用到了特定的 ClassLoader，因为这时需要从网络上加载 java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的 ClassLoader 技术。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[弗洛伊德算法及证明]]></title>
      <url>/2017/07/02/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E5%8F%8A%E8%AF%81%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>弗洛伊德算法属于动态规划问题，通过插点的方式为加权图多源点间寻求最短路径。算法引入两个二维数组path[][]和dist[][],其中dist[i][j]描述两个节点i和j间的最短路径，path[i][j]用来描述节点i和j之间最短路径所经过的节点。<br>首先，初始化非相邻节点dist为INF，得到初始矩阵S，如图所示。<br>在此鸣谢<a href="http://www.cnblogs.com/skywang12345所提供的图片" target="_blank" rel="external">http://www.cnblogs.com/skywang12345所提供的图片</a><br><img src="http://opeygftv2.bkt.clouddn.com/01.jpg" alt=""><br><a id="more"></a><br>依次一各个节点为中介节点，对矩阵S进行更新，规则为若dist[i][j] &gt; dist[i][k]+dist[k][j],则dist[i][j] = dist[i][k] + dist[k][j],path[i][j] = k ,如图所示<br><img src="http://opeygftv2.bkt.clouddn.com/02.jpg" alt=""></p>
<p>根据上述讨论，代码如下</p>
<p><pre><code><br>public class FloydDemo {<br>    private static int[] matrix;<br>    private static int[][] initMatrix;<br>    public FloydDemo(int Num,In in){<br>        matrix = new int[Num];<br>        initMatrix = new int[Num][Num];<br>        for(int i = 0; i &lt; matrix.length; i++){<br>            for(int j = 0; j &lt; matrix.length; j++){<br>                initMatrix[i][j] = in.readInt();<br>            }<br>        }<br>    }<br>    public void floyd(int[][] path,int[][] dist){<br>        for(int i = 0; i &lt; matrix.length; i++){<br>            for(int j = 0; j &lt; matrix.length; j++){<br>                dist[i][j] = initMatrix[i][j];<br>                path[i][j] = j;<br>            }<br>        }</code></pre></p>
<pre><code>    for(int k = 0; k &lt; matrix.length; k++){
        for(int i = 0; i &lt; matrix.length; i++){
            for(int j = 0; j &lt; matrix.length; j++){
                if(dist[i][j] &gt; dist[i][k] + dist[k][j]){
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = k;
                }

            }
        }
    }        
     System.out.println(&quot;floyd: \n&quot;);
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = 0; j &lt; matrix.length; j++)
                System.out.printf(&quot;%2d  &quot;, dist[i][j]);
            System.out.printf(&quot;\n&quot;);
        }
            }
public static void main(String[] args){
    In in = new In(args[0]);
    int Num = in.readInt();
    int[][] path = new int[Num][Num];
    int[][] dist = new int[Num][Num];
    new FloydDemo(Num,in).floyd(path,dist);
}
</code></pre><p>}<br><br>最终得到多源最短路径矩阵<br><img src="http://opeygftv2.bkt.clouddn.com/%E6%8D%95%E8%8E%B7.JPG" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ODL对packet_in消息的处理流程]]></title>
      <url>/2017/06/03/OpenFlowJava%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><em>OpenFlowJava对PakcetIn消息的处理流程</em></p>
<p>(1)当交换机遇到无法识别，或者需要上报的数据包（reason字段），通过与OpenFlowJava建立连接，向控制器发送消息。<br><a id="more"></a><br>(2)OpenFlowJava库对这个数据包进行解析，将解析结果发送给OpenFlowPlugin</p>
<p>(3)OpenFlowPlugin将数据包发送给控制器平台，控制器将数据包转发给监听此类数据的网络应用</p>
<p>(4)网络应用根据收到的packet_in消息判断，如果需要将报文广播发送出去，则发送Packet_out消息给控制器</p>
<p>(5)控制器到OpenFlowPlugin</p>
<p>(6)OpenFlowPlugin到OpenFlowJava</p>
<p>(7)OpenFlowJava将消息序列化之后，通过与交换机的网络连接，将消息发送出去</p>
<p>(8)通过不断的packet_in消息的传送，网络应用学习到网络的拓扑关系，根据拓扑关系组织流表项，并将流表项写入DataStore</p>
<p>(9)流规则管理器读取到DataStore的流规则变化之后，读取新加的流表项</p>
<p>(10)流规则管理项读取到的流表项通过RPC调用发送给控制器</p>
<p>(11)控制器根据RPC对应的服务名称找到对应的OpenFlowPlugin，并将流表项发送给OpenFlowPlugin</p>
<p>(12)OpenFlowPlugin将消息封装为FlowMod消息，传送给OpenFlowJava</p>
<p>(13)OpenFlowJava将消息序列化之后，通过与交换机的网络连接，将消息发送出去</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SDN </tag>
            
            <tag> ODL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM 垃圾回收机制(二)——方法区回收]]></title>
      <url>/2017/05/13/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E4%B8%80-%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<p>方法区（HotSpot中的永久代）并非没有垃圾回收机制，只是永久代的垃圾回收效率远远低于新生代回收效率。<br>永久代中垃圾回收主要包括两部分：废弃常量和无用的类。回收废弃常量与回收java堆中的对象非常相似，但判断一个类是否是无用的类就比较麻烦，类需要同时满足一下三个条件，才能算是无用的类：<br><a id="more"></a></p>
<ul>
<li>该类所有的实例都已经被回收，即java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP记忆OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代永远不会溢出。</p>
<p>注：可以使用<strong>-verbose：class</strong>以及<strong>-XX:_TraceClassLoading、-XX:TraceClassUnLoading</strong>查看类加载和卸载信息</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> GC机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（译）JVM 垃圾回收机制(一)——新生代垃圾回收]]></title>
      <url>/2017/05/10/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><strong>原作者：PATRICK PESCHLOW</strong></p>
<p><strong>本文对原文有改动</strong></p>
<p>单纯从 JVM 的功能考虑，并不需要新生代，完全可以针对整个堆进行操作。新生代存在的唯一理由是优化垃圾回收 (GC) 的性能。更具体说，把堆划分为新生代和老年代有 2 个好处：简化了新对象的分配 (只在新生代分配内存)， 可以更有效的清除不再需要的对象 (即死对象)(新生代和老年代使用不同的 GC 算法)<br><a id="more"></a><br>通过广泛研究面向对象实现的应用，发现一个共同特点：很多对象的生存时间都很短。同时研究发现，新生对象很少引用生存时间长的对象。结合这 2 个特点，很明显 GC 会频繁访问新生对象，例如在堆中一个单独的区域，称之为新生代。在新生代中，GC 可以快速标记回收” 死对象”，而不需要扫描整个 Heap 中的存活一段时间的” 老对象”。</p>
<p>SUN/Oracle 的 HotSpot JVM 又把新生代进一步划分为 3 个区域：一个相对大点的区域，称为“伊甸园区 (Eden)”；两个相对小点的区域称为“From 幸存区 (survivor)” 和“To 幸存区 (survivor)”。按照规定，新对象会首先分配在 Eden 中 (如果新对象过大，会直接分配在老年代中)。在 GC 中，Eden 中的对象会被移动到 survivor 中，直至对象满足一定的年纪 (定义为熬过 GC 的次数)，会被移动到老年代(默认为15岁)。</p>
<p>基于大多数新生对象都会在 GC 中被收回的假设。新生代的 GC 使用复制算法。在 GC 前 To 幸存区 (survivor) 保持清空，对象保存在 Eden 和 From 幸存区 (survivor) 中，GC 运行时，Eden 中的幸存对象被复制到 To 幸存区 (survivor)。针对 From 幸存区 (survivor) 中的幸存对象，会考虑对象年龄，如果年龄没达到阀值 (tenuring threshold)，对象会被复制到 To 幸存区 (survivor)。如果达到阀值对象被复制到老年代。复制阶段完成后，Eden 和 From 幸存区中只保存死对象，可以视为清空。如果在Survivor空间中相同年龄所有对象大小的总和超过了Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。<br><img src="http://opeygftv2.bkt.clouddn.com/1.png" alt=""><br>上图演示 GC 过程，黄色表示死对象，绿色表示剩余空间，红色表示幸存对象</p>
<p>总结一下，对象一般出生在 Eden 区，年轻代 GC 过程中，对象在 2 个幸存区之间移动，如果对象存活到适当的年龄，会被移动到老年代。当对象在老年代死亡时，就需要更高级别的 GC，更重量级的 GC 算法 (复制算法不适用于老年代，因为没有多余的空间用于复制)</p>
<p>现在应该能理解为什么新生代大小非常重要了 (译者，有另外一种说法：新生代大小并不重要，影响 GC 的因素主要是幸存对象的数量)，如果新生代过小，会导致新生对象很快就晋升到老年代中，在老年代中对象很难被回收。如果新生代过大，会发生过多的复制过程。我们需要找到一个合适大小，不幸的是，要想获得一个合适的大小，只能通过不断的测试调优。这就需要 JVM 参数了</p>
<p><strong>-XX:NewSize and -XX:MaxNewSize</strong></p>
<p>就像可以通过参数 (-Xms and -Xmx) 指定堆大小一样，可以通过参数指定新生代大小。设置 XX:MaxNewSize 参数时，应该考虑到新生代只是整个堆的一部分，新生代设置的越大，老年代区域就会减少。一般不允许新生代比老年代还大，因为要考虑 GC 时最坏情况，所有对象都晋升到老年代。(译者: 会发生 OOM 错误) -XX:MaxNewSize 最大可以设置为 - Xmx/2。</p>
<p>考虑性能，一般会通过参数 -XX:NewSize 设置新生代初始大小。如果知道新生代初始分配的对象大小 (经过监控)，这样设置会有帮助，可以节省新生代自动扩展的消耗。</p>
<p><strong>-XX:NewRatio</strong></p>
<p>可以设置新生代和老年代的相对大小。这种方式的优点是新生代大小会随着整个堆大小动态扩展。参数 -XX:NewRatio 设置老年代与新生代的比例。例如 -XX:NewRatio=3 指定老年代 / 新生代为 3/1。 老年代占堆大小的 3/4，新生代占 1/4 。</p>
<p>如果针对新生代，同时定义绝对值和相对值，绝对值将起作用。下面例子：</p>
<p><code>$ java -XX:NewSize=32m -XX:MaxNewSize=512m -XX:NewRatio=3 MyApp</code></p>
<p>以上设置，JVM 会尝试为新生代分配四分之一的堆大小，但不会小于 32MB 或大于 521MB</p>
<p>在设置新生代大小问题上，使用绝对值还是相对值，不存在通用准则 。如果了解应用的内存使用情况， 设置固定大小的堆和新生代更有利，当然也可以设置相对值。如果对应用的内存使用一无所知，正确的做法是不要设置任何参数，如果应用运行良好。很好，我们不用做任何额外动作。如果遇到性能或 OutOfMemoryErrors，在调优之前，首先需要进行一系列有目的的监控测试，缩小问题的根源。</p>
<p><strong>-XX:SurvivorRatio</strong></p>
<p>参数 -XX:SurvivorRatio 与 -XX:NewRatio 类似，作用于新生代内部区域。-XX:SurvivorRatio 指定伊甸园区 (Eden) 与幸存区大小比例。 例如， -XX:SurvivorRatio=10 表示伊甸园区 (Eden) 是 幸存区 To 大小的 10 倍 (也是幸存区 From 的 10 倍)。 所以， 伊甸园区 (Eden) 占新生代大小的 10/12， 幸存区 From 和幸存区 To 每个占新生代的 1/12 。 注意， 两个幸存区永远是一样大的。</p>
<p>设定幸存区大小有什么作用? 假设幸存区相对伊甸园区 (Eden) 太小， 相应新生对象的伊甸园区 (Eden) 永远很大空间， 我们当然希望， 如果这些对象在 GC 时全部被回收， 伊甸园区 (Eden) 被清空， 一切正常。 然而， 如果有一部分对象在 GC 中幸存下来， 幸存区只有很少空间容纳这些对象。 结果大部分幸存对象在一次 GC 后，就会被转移到老年代 ， 这并不是我们希望的。 考虑相反情况， 假设幸存区相对伊甸园区 (Eden) 太大， 当然有足够的空间，容纳 GC 后的幸存对象。 但是过小的伊甸园区 (Eden)， 意味着空间将越快耗尽，增加新生代 GC 次数，这是不可接受的。</p>
<p>总之， 我们希望最小化短命对象晋升到老年代的数量，同时也希望最小化新生代 GC 的次数和持续时间。 我们需要找到针对当前应用的折中方案， 寻找适合方案的起点是 了解当前应用中对象的年龄分布情况。</p>
<p>-XX:+PrintTenuringDistribution</p>
<p>参数 -XX:+PrintTenuringDistribution 指定 JVM 在每次新生代 GC 时，输出幸存区中对象的年龄分布。例如:</p>
<p><pre><code><br>Desired survivor size 75497472 bytes， new threshold 15 (max 15)<br>age 1: 19321624 bytes， 19321624 total<br>age 2: 79376 bytes， 19401000 total<br>age 3: 2904256 bytes， 22305256 total<br></code></pre><br>第一行说明幸存区 To 大小为 75 MB。 也有关于老年代阀值 (tenuring threshold) 的信息， 老年代阀值，意思是对象从新生代移动到老年代之前，经过几次 GC(即， 对象晋升前的最大年龄)。 上例中， 老年代阀值为 15， 最大也是 15。</p>
<p>之后行表示，对于小于老年代阀值的每一个对象年龄，本年龄中对象所占字节 (如果当前年龄没有对象， 这一行会忽略)。 上例中， 一次 GC 后幸存对象大约 19 MB， 两次 GC 后幸存对象大约 79 KB，三次 GC 后幸存对象大约 3 MB 。 每行结尾，显示直到本年龄全部对象大小。 所以， 最后一行的 total 表示幸存区 To 总共被占用 22 MB 。 幸存区 To 总大小为 75 MB ， 当前老年代阀值为 15，可以断定在本次 GC 中，没有对象会移动到老年代。现在假设下一次 GC 输出为：</p>
<p><pre><code><br>Desired survivor size 75497472 bytes， new threshold 2 (max 15)<br>age 1: 68407384 bytes， 68407384 total<br>age 2: 12494576 bytes， 80901960 total<br>age 3: 79376 bytes， 80981336 total<br>age 4: 2904256 bytes， 83885592 total<br></code></pre><br>对比前一次老年代分布。明显的， 年龄 2 和年龄 3 的对象还保持在幸存区中，因为我们看到年龄 3 和 4 的对象大小与前一次年龄 2 和 3 的相同。同时发现幸存区中， 有一部分对象已经被回收， 因为本次年龄 2 的对象大小为 12MB ，而前一次年龄 1 的对象大小为 19 MB。最后可以看到最近的 GC 中，有 68 MB 新对象，从伊甸园区移动到幸存区。</p>
<p>注意， 本次 GC 幸存区占用总大小 84 MB - 大于 75 MB。 结果， JVM 把老年代阀值从 15 降低到 2，在下次 GC 时，一部分对象会强制离开幸存区，这些对象可能会被回收 (如果他们刚好死亡) 或移动到老年代。</p>
<p><strong>-XX:InitialTenuringThreshold， -XX:MaxTenuringThreshold and -XX:TargetSurvivorRatio</strong></p>
<p>参数 -XX:+PrintTenuringDistribution 输出中的部分值可以通过其它参数控制。通过 -XX:InitialTenuringThreshold 和 -XX:MaxTenuringThreshold 可以设定老年代阀值的初始值和最大值。另外， 可以通过参数 -XX:TargetSurvivorRatio 设定幸存区的目标使用率。 例如， -XX:MaxTenuringThreshold=10 -XX:TargetSurvivorRatio=90 设定老年代阀值的上限为 10， 幸存区空间目标使用率为 90%。</p>
<p>有多种方式， 设置新生代行为，没有通用准则。我们必须清楚以下 2 中情况：</p>
<ul>
<li>如果从年龄分布中发现，有很多对象的年龄持续增长，在到达老年代阀值之前。这表示 -XX:MaxTenuringThreshold 设置过大</li>
<li>如果 -XX:MaxTenuringThreshold 的值大于 1，但是很多对象年龄从未大于 1。应该看下幸存区的目标使用率。如果幸存区使用率从未到达，这表示对象都被 GC 回收，这正是我们想要的。 如果幸存区使用率经常达到，有些年龄超过 1 的对象被移动到老年代中。这种情况，可以尝试调整幸存区大小或目标使用率。<br><strong>-XX:+NeverTenure and -XX:+AlwaysTenure</strong></li>
</ul>
<p>最后，我们介绍 2 个颇为少见的参数，对应 2 种极端的新生代 GC 情况。设置参数 -XX:+NeverTenure，对象永远不会晋升到老年代。当我们确定不需要老年代时，可以这样设置。这样设置风险很大， 并且会浪费至少一半的堆内存。相反设置参数 -XX:+AlwaysTenure，表示没有幸存区，所有对象在第一次 GC 时，会晋升到老年代。</p>
<p>没有合理的场景使用这个参数。可以在测试环境中，看下这样设置会发生什么有趣的事。但是并不推荐使用这些参数。</p>
<p>结论 适当的配置新生代非常重要，有相当多的参数可以设置新生代。然而，单独调整新生代，而不考虑老年代是不可能优化成功的。当调整堆和 GC 设置时，我们总是应该同时考虑新生代和老年代。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> GC机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[容器技术与虚拟机]]></title>
      <url>/2017/05/04/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>云计算的本质是集中资源再分配，再分配的过程就是资源的逻辑划分，提供资源抽象的实现方式。其中主要涉及两个方面，资源控制和资源隔离。</p>
<p>居然一直都无法准确表述镜像的概念，所谓镜像，包括各种打包的Apps、系统使用进程、应用软件、shell以及公用函数库。</p>
<h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><a id="more"></a>
<p><img src="http://opeygftv2.bkt.clouddn.com/blog_%E5%9B%BE%E7%89%871.png" alt=""></p>
<p>虚拟机的Guest OS即为虚拟机安装的操作系统，它是一个完整操作系统内核；虚拟机的Hypervisor层可以简单理解为一个硬件虚拟化平台(VMW、VirtualBox)，它在Host OS是以内核态的驱动存在的。<br>虚拟机实现<strong>资源隔离</strong>的方法是利用独立的OS，并利用Hypervisor虚拟化CPU、内存、IO设备等实现的。</p>
<ul>
<li><p>为了虚拟CPU，Hypervisor会为每个虚拟的CPU创建一个<strong>数据结构</strong>，模拟CPU的全部寄存器的值，在适当的时候跟踪并修改这些值。需要指出的是在大多数情况下，虚拟机软件代码是直接跑在硬件上的，而不需要Hypervisor介入。只有在一些权限高的请求下，Guest OS需要运行内核态修改CPU的寄存器数据，Hypervisor会介入，修改并维护虚拟的CPU状态。 </p>
</li>
<li><p>Hypervisor虚拟化内存的方法是创建一个shadow page table。正常的情况下，一个page table可以用来实现从虚拟内存到物理内存的翻译。在虚拟化的情况下，由于所谓的物理内存仍然是虚拟的，因此shadow page table就要做到：<strong>虚拟内存-&gt;虚拟的物理内存-&gt;真正的物理内存</strong>。 </p>
</li>
<li><p>对于IO设备虚拟化，当Hypervisor接到page fault，并发现实际上虚拟的物理内存地址对应的是一个I/O设备，Hypervisor就用软件模拟这个设备的工作情况，并返回。比如当CPU想要写磁盘时，Hypervisor就把相应的数据写到一个host OS的文件上，这个文件实际上就模拟了虚拟的磁盘。 </p>
</li>
</ul>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>容器技术的出现远远早于Docker，Docker只是提供了一个能够方便管理容器的工具并为其提供了标准。Docker相当于把应用以及应用所依赖的环境完整打成一个包，这个包不管拿到哪里都能够原生运行。</p>
<p><img src="http://opeygftv2.bkt.clouddn.com/blog_%E5%9B%BE%E7%89%872.png" alt=""></p>
<p>docker Engine可以简单看成对Linux的NameSpace、Cgroup、镜像管理文件系统操作的封装。docker并没有和虚拟机一样利用一个完全独立的Guest OS实现环境隔离，它利用的是目前Linux内核本身支持的容器方式,主要是Namespace和CGroup来实现资源和环境隔离。其中namespace实现系统环境的隔离，Cgroup实现资源限制，而利用镜像实现根目录环境的隔离。</p>
<p>通过docker和虚拟机实现原理的比较，我们大致可以得出一些结论： </p>
<ul>
<li>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有优势。在IO设备虚拟化上，docker的镜像管理有多种方案，比如利用Aufs文件系统或者Device Mapper实现docker的文件管理，各种实现方案的效率略有不同。 </li>
<li>docker利用的是宿主机的内核，而不需要Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。我们知道，引导、加载操作系统内核是一个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统，则省略了这个过程，因此新建一个docker容器只需要几秒钟。另外，现代操作系统是复杂的系统，在一台物理机上新增加一个操作系统的资源开销是比较大的，因此，docker对比虚拟机在资源消耗上也占有比较大的优势。事实上，在一台物理机上我们可以很容易建立成百上千的容器，而只能建立几个虚拟机。</li>
</ul>
<h1 id="CGroup与Namespace"><a href="#CGroup与Namespace" class="headerlink" title="CGroup与Namespace"></a>CGroup与Namespace</h1><ul>
<li>CGroup<br>将一组进程放在一个控制组里，通过给这个控制组分配指定的可用资源，达到控制这一组进程可用资源的目的。</li>
<li>Namespace<br>Namespace是将内核的全局资源做封装，使得每个Namespace都有一份独立的资源，因此不同的进程在各自的Namespace内对同一种资源的实用不会相互干扰。Linux总共实现了6种Namespace：<ul>
<li>IPC：隔离System VIPC和POSIX消息队列</li>
<li>Network ： 隔离网络资源</li>
<li>Mount  隔离文件系统挂载点</li>
<li>PID  ：隔离进程ID</li>
<li>UTS ：隔离主机名和域名</li>
<li>User ：隔离用户ID和组ID </li>
</ul>
</li>
</ul>
<p>容器 = CGroup + NameSpace+rootfs+容器引擎</p>
<p>rootfs：文件隔离控制<br>容器引擎： 生命周期控制</p>
<h1 id="Docker与虚拟机的优劣"><a href="#Docker与虚拟机的优劣" class="headerlink" title="Docker与虚拟机的优劣"></a>Docker与虚拟机的优劣</h1><ul>
<li><p>虚拟机</p>
<ul>
<li>由于虚拟机镜像必须依赖于Guest OS这一庞大的内核，因此十分臃肿，无法在一台物理主机上大量建立</li>
<li>由于虚拟机启动前必须先启动Guest OS,因此，创建和启动的时间开销大</li>
<li>使用虚拟资源会存在资源损耗</li>
<li>部署密度小</li>
</ul>
</li>
<li><p>Docker优势</p>
<ul>
<li>镜像体积小，只包括apps以及所依赖的环境，没有内核</li>
<li>创建启动时间开销小</li>
<li>没有Guest OS和hypervisor，无额外资源开销，资源控制粒度小，部署密度大</li>
<li>使用的是真实的物力资源，不存在资源损耗</li>
</ul>
</li>
<li><p>Docker劣势<br>docker的劣势</p>
<ul>
<li>资源隔离方面不如虚拟机，docker是利用cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源。 </li>
<li>安全性问题。docker目前并不能分辨具体执行指令的用户，只要一个用户拥有执行docker的权限，那么他就可以对docker的容器进行所有操作，不管该容器是否是由该用户创建。比如A和B都拥有执行docker的权限，由于docker的server端并不会具体判断docker cline是由哪个用户发起的，A可以删除B创建的容器，存在一定的安全风险。 </li>
<li>docker目前还在版本的快速更新中，细节功能调整比较大。一些核心模块依赖于高版本内核，存在版本兼容问题</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[春华秋实]]></title>
      <url>/2017/05/03/%E5%8D%97%E4%BA%AC/</url>
      <content type="html"><![CDATA[<p><img src="http://opeygftv2.bkt.clouddn.com/_DSC1096_%E5%89%AF%E6%9C%AC.jpg" alt=""><br><a id="more"></a><br><img src="http://opeygftv2.bkt.clouddn.com/_DSC1072_%E5%89%AF%E6%9C%AC.jpg" alt=""><br><img src="http://opeygftv2.bkt.clouddn.com/_DSC1102_%E5%89%AF%E6%9C%AC.jpg" alt=""><br><img src="http://opeygftv2.bkt.clouddn.com/_DSC1089_%E5%89%AF%E6%9C%AC.jpg" alt=""><br><img src="http://opeygftv2.bkt.clouddn.com/_DSC1110_%E5%89%AF%E6%9C%AC.jpg" alt=""><br><img src="http://opeygftv2.bkt.clouddn.com/_DSC1157_%E5%89%AF%E6%9C%AC.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> travelog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[斐波那契堆]]></title>
      <url>/2017/05/02/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/</url>
      <content type="html"><![CDATA[<p><img src="http://opeygftv2.bkt.clouddn.com/829863-20160104171120950-2110922480.png" alt=""><br><a id="more"></a><br>一个斐波那契堆具有如下性质：</p>
<p>堆有一组有序树组成，但是堆中的树不一定是二项树</p>
<p>斐波那契堆中的树之间是无序的（二项堆中的树是按照其包含的二项树的度数排序的）</p>
<p>堆中每个节点的数据结构包含如下域：</p>
<p>指向其父节点的指针域</p>
<p>指向其任意一个孩子的指针域</p>
<p>任意一个节点x的所有孩子被链接在一个双向链表环形链表中</p>
<p>节点x中保存有它的孩子的数目degree</p>
<p>节点x中存在一个域mark，用于表示自从x上一次称为另一个节点的子女以来，它是否失掉了一个孩子，TRUE表示是失去了，FALSE表示未失去<br>斐波那契堆中的所有树的树根被保存在一个链表即根表中<br>对于一个斐波那契堆，min[H]保存了具有最小节点值的根节点<br>在计算机科学中，斐波那契堆是由树的集合所组成的堆数据结构。它比二项堆的平摊运行时间更好。斐波那契堆的名字来自于斐波那契数列，这些数列被用来做运行时间分析。</p>
<p>求最小值(find-mininum), 插入(insert), 降低元素值(decrease-key)和合并(merge/union)可以在常数平摊时间内完成。删除(delete)和删除最小值(delete minimun)可以在O(log n)平摊时间内完成。</p>
<p>在优先队列(priority queues)中使用斐波那契堆可以提升重要算法的渐进运行时间，例如Dijkstra算法，该算法用来计算一个图中两个结点的最短的距离。</p>
<p>斐波那契堆是由一些树的集合所组成，其中每一棵树都满足最小堆(minimum-heap)的属性，也就是说树中每个子结点的值都大于或者等于其父结点的值，而最小值则处在根结点上。</p>
<p>与二项堆不同，斐波那契堆中的树更加灵活，没有规定的形状，在极端情况下，堆中每个元素都是一棵单独的树。这种灵活性使得一些操作可以以“偷懒”的方式来执行，而“剩下”的工作将推迟到后面的操作中来完成。比如堆的合并仅仅将由树所组成的链表链接起来，而降低元素值(decrease key)有时直接从父结点中剪断而形成一棵新树。</p>
<p>下面给出斐波那契堆中关键的量值：</p>
<p>degree[x]:degree[x]: 表示结点x的子结点个数</p>
<p>mark[x]:mark[x]: 一个结点是否被marked了（当执行decrease key操作时会用到）</p>
<p>t(H):t(H): 表示堆中树的个数</p>
<p>m(H):m(H): 表示被marked的结点数量</p>
<p>Φ(H)=t(H)+2m(H):Φ(H)=t(H)+2m(H): 表示势函数</p>
<p>如下图所示：<br>从图中可以看出，一共有5棵树，即t(H)=5t(H)=5，最小值的指针指向元素值为3的根结点，在这棵包含最小值的树中，根结点有3个子结点，所以其degree等于3，整个斐波那契堆用 H 来表示。其中黑色表示被marked了，灰色表示没有被marked，所以m(H)=3m(H)=3，势函数 Φ(H)=t(H)+2m(H)=5+2∗3=11Φ(H)=t(H)+2m(H)=5+2∗3=11</p>
<p><img src="http://opeygftv2.bkt.clouddn.com/20131028210633593.gif" alt=""></p>
<pre><code>
Make-Fibonacci-Heap()
n[H] := 0
min[H] := NIL 
return H

Fibonacci-Heap-Minimum(H)
return min[H]

Fibonacci-Heap-Link(H,y,x)
remove y from the root list of H
make y a child of x
degree[x] := degree[x] + 1
mark[y] := FALSE

CONSOLIDATE(H)
for i:=0 to D(n[H])
     Do A[i] := NIL
for each node w in the root list of H
    do x:= w
       d:= degree[x]
       while A[d] <> NIL
           do y:=A[d]
              if key[x]>key[y]
                then exchange x<->y
              Fibonacci-Heap-Link(H, y, x)
              A[d]:=NIL
             d:=d+1
       A[d]:=x
min[H]:=NIL
for i:=0 to D(n[H])
    do if A[i]<> NIL
          then add A[i] to the root list of H
               if min[H] = NIL or key[A[i]]<key[min[h]] then="" min[h]:="A[i]" fibonacci-heap-union(h1,h2)="" h="" :="Make-Fibonacci-Heap()" min[h]="" concatenate="" the="" root="" list="" of="" h2="" with="" if="" (min[h1]="NIL)" or="" (min[h2]="" <=""> NIL and min[H2] < min[H1])
   then min[H] := min[H2]
n[H] := n[H1] + n[H2]
free the objects H1 and H2
return H


Fibonacci-Heap-Insert(H,x)
degree[x] := 0
p[x] := NIL
child[x] := NIL
left[x] := x
right[x] := x
mark[x] := FALSE
concatenate the root list containing x with root list H
if min[H] = NIL or key[x]<key[min[h]] then="" min[h]="" :="x" n[h]:="n[H]+1" fibonacci-heap-extract-min(h)="" z:="min[H]" if="" x="" <=""> NIL
        then for each child x of z
             do add x to the root list of H
                p[x]:= NIL
             remove z from the root list of H
             if z = right[z]
                then min[H]:=NIL
                else min[H]:=right[z]
                     CONSOLIDATE(H)
             n[H] := n[H]-1
return z

Fibonacci-Heap-Decrease-Key(H,x,k)
if k > key[x]
   then error "new key is greater than current key"
key[x] := k
y := p[x]
if y <> NIL and key[x]<key[y] then="" cut(h,="" x,="" y)="" cascading-cut(h,y)="" if="" key[x]<key[min[h]]="" min[h]="" :="x" cut(h,x,y)="" remove="" x="" from="" the="" child="" list="" of="" y,="" decrementing="" degree[y]="" add="" to="" root="" h="" p[x]:="NIL" mark[x]:="FALSE" z:="p[y]" z="" <=""> NIL
  then if mark[y] = FALSE
       then mark[y]:= TRUE
       else CUT(H, y, z)
            CASCADING-CUT(H, z)

Fibonacci-Heap-Delete(H,x)
Fibonacci-Heap-Decrease-Key(H,x,-infinity)
Fibonacci-Heap-Extract-Min(H)
 </key[y]></key[min[h]]></key[min[h]]></-></code></pre>

<p>关于斐波那契堆的操作具体参见<br><a href="http://gdeepak.com/IADSA/L22binomialfibonacciheaps.pdf" target="_blank" rel="external">http://gdeepak.com/IADSA/L22binomialfibonacciheaps.pdf</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Latch]]></title>
      <url>/2017/04/28/Latch/</url>
      <content type="html"><![CDATA[<p>#Latch</p>
<p><strong>同步工具</strong>类除了最熟悉的阻塞队列之外，还包括<strong>Semaphore、Barrier</strong>以及<strong>Latch</strong>。同样，我们也可以创建属于自己的同步工具类。所有的同步工具类都包含了一些特定的结构属性：比如，封装了一些状态，而这些状态将决定执行同步工具类的线程是继续执行还是等待，除此而外，还提供了一些方法对状态进行操作，以及高效的等待同步工具类进入到预期的状态。<br><a id="more"></a><br><strong>闭锁</strong>最形象的比喻是一扇Gate，在闭锁到达结束状态之前，这扇门始终处于关闭的状态，任何线程都无法通过。而当闭锁到达结束状态，这扇门将打开，进而允许所有的线程通过。一旦闭锁达到结束状态，这扇门将保持打开的状态，不会再关闭。换句话说，闭锁的作用是保持某些活动直到其他活动都完成才继续执行。<br>举个例子，我们都知道并发在某些情况下，可以极大地提升工作效率，缩短程序的运行时间，那么我们该如何去获取并发程序准确的运行时间，即在所有线程全部就绪的时刻启动时间，而在所有线程全部结束的时刻终止时间。Latch可以做到，看下面程序。</p>
<pre><code><java>
public class TestHarness {
    public static String timeTask(int nThreads,final Runnable[] tasks) throws InterruptedException{
        final CountDownLatch startGate=new CountDownLatch(1);
        final CountDownLatch endGate=new CountDownLatch(nThreads);
        for(Runnable task:tasks){
            Thread t=new Thread(){
                public void run(){
                    try{
                        startGate.await();
                        try{
                            task.run();
                        }finally{
                            //每个线程最终最后执行将endGate减1
                            endGate.countDown();

                        }
                    }catch(InterruptedException e){

                    }
                }
            };
            t.start();
        }
        long startTime=System.nanoTime();
        startGate.countDown();
        endGate.await();
        long endTime=System.nanoTime();
        return "Time: "+(endTime-startTime)+"ns";
    }
</java></code></pre>

<p>由于startGate被设置为等待</p>
<p><code>startGate.await();</code></p>
<p>因此每个线程首先要做的工作就是在启动门上等待，直到所有的线程全部就绪。并且，我们在为每个线程装载任务时</p>
<p><code>finally{endGate.countDown();}</code></p>
<p>保证没个线程最终都会执行使得endGate减1的任务</p>
<p><code>startGate.countDown();</code></p>
<p>注意startGate的初值为1，因此调用countDown方法后，门打开，此时线程开始执行</p>
<p><code>endGate.await();</code></p>
<p>endGate此时关闭，要做的工作就是等待且为零的时刻，然后打开</p>
<p>如果没用使用Latch工具而去获取并行线程的运行时间，线程在被创建之后将立即执行，显然，先启动的线程势必会领先于后启动的线程，并且活跃线程的数量会随着时间的推移而慢慢减少或者增加，竞争程度也将发生变化。有了这个工具，我们今后在编写并发程序是，只需要调用timeTasks函数，并向其传递任务参数，就可以获取并发时间了。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[五月任务计划]]></title>
      <url>/2017/04/28/%E4%BA%94%E6%9C%88%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p>###技术目标</p>
<ul>
<li>深入研究<strong>OSGi</strong>，理解java模块化编程，以及OSGi如何打破类加载机制的双亲委派模型<br> 预期目标：开发一个<strong>Opendaylight</strong>可用的Bundle，具体功能为获取网络拓普信息并建路</li>
<li>结合Spring技术内幕一书，研究<strong>Spring</strong>源码，并以此进一步锤炼java</li>
<li>尝试编译OpenJDK<a id="more"></a>
###论文目标</li>
<li>5号之间将论文搞定</li>
<li>15号之前完成论文翻译工作</li>
</ul>
<p>####出行</p>
<ul>
<li>争取在月内和女神实现<strong>厦门</strong>行</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> planning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[synchronized关键字]]></title>
      <url>/2017/04/28/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>在<strong>并发编程</strong>中，多线程同时并发访问的资源叫做<strong>临界资源</strong>，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机制，以确保在某一时刻，方法内只允许有一个线程。</p>
<p>采用 synchronized 修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个 monitor (锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。<br><a id="more"></a><br>这里就使用同步机制获取互斥锁的情况，进行几点说明：</p>
<p>1、如果同一个方法内同时有两个或更多线程，则每个线程有自己的<strong>局部变量</strong>拷贝。</p>
<p>2、类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的 synchronized 同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问 synchronized 同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。</p>
<p>3、访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。</p>
<p>4、持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非 synchronized 代码。当一个线程 A 持有一个对象级别锁（即进入了 synchronized 修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程 B 有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用 synchronized 修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让 A 线程运行，A 线程继续持有对象级别锁，当 A 线程退出同步代码时（即释放了对象级别锁），如果 B 线程此时再运行，便会获得该对象级别锁，从而执行 synchronized 中的代码。</p>
<p>5、持有对象级别锁的线程会让其他线程阻塞在所有的 synchronized 代码外。例如，在一个类中有三个synchronized 方法 a，b，c，当线程 A 正在执行一个实例对象 M 中的方法 a 时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象 M）中的代码时，便会在所有的 synchronized 方法处阻塞，即在方法 a，b，c 处都要被阻塞，等线程 A 释放掉对象级别锁时，其他的线程才可以去执行方法 a，b 或者 c 中的代码，从而获得该对象级别锁。</p>
<p>6、使用 synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj 为对象的引用，如果获取了 obj 对象上的对象级别锁，在并发访问 obj 对象时时，便会在其 synchronized 代码处阻塞等待，直到获取到该 obj对象的对象级别锁。当 obj 为 this 时，便是获取当前对象的对象级别锁。</p>
<p>7、类级别锁被特定类的所有示例共享，它用于控制对 static 成员变量以及 static 方法的并发访问。具体用法与对象级别锁相似。</p>
<p>8、互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized 关键字经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加 1，相应地，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁便被释放了。由于 synchronized 同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
