<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>斐波那契堆 - Lex-Zhao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#斐波那契堆一个斐波那契堆具有如下性质： 堆有一组有序树组成，但是堆中的树不一定是二项树斐波那契堆中的树之间是无序的（二项堆中的树是按照其包含的二项树的度数排序的）堆中每个节点的数据结构包含如下域：指向其父节点的指针域指向其任意一个孩子的指针域任意一个节点x的所有孩子被链接在一个双向链表环形链表中节点x中保存有它的孩子的数目degree节点x中存在一个域mark，用于表示自从x上一次称为另一个节点">
<meta name="keywords" content="Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="斐波那契堆">
<meta property="og:url" content="http://www.lex-zhao.xyz/2017/05/02/斐波那契堆/index.html">
<meta property="og:site_name" content="Lex-Zhao">
<meta property="og:description" content="#斐波那契堆一个斐波那契堆具有如下性质： 堆有一组有序树组成，但是堆中的树不一定是二项树斐波那契堆中的树之间是无序的（二项堆中的树是按照其包含的二项树的度数排序的）堆中每个节点的数据结构包含如下域：指向其父节点的指针域指向其任意一个孩子的指针域任意一个节点x的所有孩子被链接在一个双向链表环形链表中节点x中保存有它的孩子的数目degree节点x中存在一个域mark，用于表示自从x上一次称为另一个节点">
<meta property="og:image" content="file:///G:/blog/source/uploads/829863-20160104171120950-2110922480.png">
<meta property="og:image" content="file:///G:/blog/source/uploads/20131028210633593.gif">
<meta property="og:updated_time" content="2017-05-02T06:59:43.154Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="斐波那契堆">
<meta name="twitter:description" content="#斐波那契堆一个斐波那契堆具有如下性质： 堆有一组有序树组成，但是堆中的树不一定是二项树斐波那契堆中的树之间是无序的（二项堆中的树是按照其包含的二项树的度数排序的）堆中每个节点的数据结构包含如下域：指向其父节点的指针域指向其任意一个孩子的指针域任意一个节点x的所有孩子被链接在一个双向链表环形链表中节点x中保存有它的孩子的数目degree节点x中存在一个域mark，用于表示自从x上一次称为另一个节点">
<meta name="twitter:image" content="file:///G:/blog/source/uploads/829863-20160104171120950-2110922480.png">
  
  
    <link rel="icon" href="/hexo.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.lex-zhao.xyz"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-斐波那契堆" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      斐波那契堆
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/05/02/斐波那契堆/" class="article-date">
  <time datetime="2017-05-02T05:10:07.000Z" itemprop="datePublished">2017-05-02</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>#斐波那契堆<br>一个斐波那契堆具有如下性质：</p>
<p>堆有一组有序树组成，但是堆中的树不一定是二项树<br>斐波那契堆中的树之间是无序的（二项堆中的树是按照其包含的二项树的度数排序的）<br>堆中每个节点的数据结构包含如下域：<br>指向其父节点的指针域<br>指向其任意一个孩子的指针域<br>任意一个节点x的所有孩子被链接在一个双向链表环形链表中<br>节点x中保存有它的孩子的数目degree<br>节点x中存在一个域mark，用于表示自从x上一次称为另一个节点的子女以来，它是否失掉了一个孩子，TRUE表示是失去了，FALSE表示未失去<br>斐波那契堆中的所有树的树根被保存在一个链表即根表中<br>对于一个斐波那契堆，min[H]保存了具有最小节点值的根节点<br>下图即为一个斐波那契堆的示例：<br><img src="file:///G:/blog/source/uploads/829863-20160104171120950-2110922480.png" alt=""><br>在计算机科学中，斐波那契堆是由树的集合所组成的堆数据结构。它比二项堆的平摊运行时间更好。斐波那契堆的名字来自于斐波那契数列，这些数列被用来做运行时间分析。</p>
<p>求最小值(find-mininum), 插入(insert), 降低元素值(decrease-key)和合并(merge/union)可以在常数平摊时间内完成。删除(delete)和删除最小值(delete minimun)可以在O(log n)平摊时间内完成。</p>
<p>在优先队列(priority queues)中使用斐波那契堆可以提升重要算法的渐进运行时间，例如Dijkstra算法，该算法用来计算一个图中两个结点的最短的距离。</p>
<p>斐波那契堆是由一些树的集合所组成，其中每一棵树都满足最小堆(minimum-heap)的属性，也就是说树中每个子结点的值都大于或者等于其父结点的值，而最小值则处在根结点上。</p>
<p>与二项堆不同，斐波那契堆中的树更加灵活，没有规定的形状，在极端情况下，堆中每个元素都是一棵单独的树。这种灵活性使得一些操作可以以“偷懒”的方式来执行，而“剩下”的工作将推迟到后面的操作中来完成。比如堆的合并仅仅将由树所组成的链表链接起来，而降低元素值(decrease key)有时直接从父结点中剪断而形成一棵新树。</p>
<p>下面给出斐波那契堆中关键的量值：</p>
<p>degree[x]:degree[x]: 表示结点x的子结点个数</p>
<p>mark[x]:mark[x]: 一个结点是否被marked了（当执行decrease key操作时会用到）</p>
<p>t(H):t(H): 表示堆中树的个数</p>
<p>m(H):m(H): 表示被marked的结点数量</p>
<p>Φ(H)=t(H)+2m(H):Φ(H)=t(H)+2m(H): 表示势函数</p>
<p>如下图所示：</p>
<p>从图中可以看出，一共有5棵树，即t(H)=5t(H)=5，最小值的指针指向元素值为3的根结点，在这棵包含最小值的树中，根结点有3个子结点，所以其degree等于3，整个斐波那契堆用 H 来表示。其中黑色表示被marked了，灰色表示没有被marked，所以m(H)=3m(H)=3，势函数 Φ(H)=t(H)+2m(H)=5+2∗3=11Φ(H)=t(H)+2m(H)=5+2∗3=11<br><img src="file:///G:/blog/source/uploads/20131028210633593.gif" alt=""></p>
<p>###Algorithm for Fibonacci Heap Operations</p>
<pre><code>
Make-Fibonacci-Heap()
n[H] := 0
min[H] := NIL 
return H

Fibonacci-Heap-Minimum(H)
return min[H]

Fibonacci-Heap-Link(H,y,x)
remove y from the root list of H
make y a child of x
degree[x] := degree[x] + 1
mark[y] := FALSE

CONSOLIDATE(H)
for i:=0 to D(n[H])
     Do A[i] := NIL
for each node w in the root list of H
    do x:= w
       d:= degree[x]
       while A[d] <> NIL
           do y:=A[d]
              if key[x]>key[y]
                then exchange x<->y
              Fibonacci-Heap-Link(H, y, x)
              A[d]:=NIL
             d:=d+1
       A[d]:=x
min[H]:=NIL
for i:=0 to D(n[H])
    do if A[i]<> NIL
          then add A[i] to the root list of H
               if min[H] = NIL or key[A[i]]<key[min[h]] then="" min[h]:="A[i]" fibonacci-heap-union(h1,h2)="" h="" :="Make-Fibonacci-Heap()" min[h]="" concatenate="" the="" root="" list="" of="" h2="" with="" if="" (min[h1]="NIL)" or="" (min[h2]="" <=""> NIL and min[H2] < min[H1])
   then min[H] := min[H2]
n[H] := n[H1] + n[H2]
free the objects H1 and H2
return H


Fibonacci-Heap-Insert(H,x)
degree[x] := 0
p[x] := NIL
child[x] := NIL
left[x] := x
right[x] := x
mark[x] := FALSE
concatenate the root list containing x with root list H
if min[H] = NIL or key[x]<key[min[h]] then="" min[h]="" :="x" n[h]:="n[H]+1" fibonacci-heap-extract-min(h)="" z:="min[H]" if="" x="" <=""> NIL
        then for each child x of z
             do add x to the root list of H
                p[x]:= NIL
             remove z from the root list of H
             if z = right[z]
                then min[H]:=NIL
                else min[H]:=right[z]
                     CONSOLIDATE(H)
             n[H] := n[H]-1
return z

Fibonacci-Heap-Decrease-Key(H,x,k)
if k > key[x]
   then error "new key is greater than current key"
key[x] := k
y := p[x]
if y <> NIL and key[x]<key[y] then="" cut(h,="" x,="" y)="" cascading-cut(h,y)="" if="" key[x]<key[min[h]]="" min[h]="" :="x" cut(h,x,y)="" remove="" x="" from="" the="" child="" list="" of="" y,="" decrementing="" degree[y]="" add="" to="" root="" h="" p[x]:="NIL" mark[x]:="FALSE" z:="p[y]" z="" <=""> NIL
  then if mark[y] = FALSE
       then mark[y]:= TRUE
       else CUT(H, y, z)
            CASCADING-CUT(H, z)

Fibonacci-Heap-Delete(H,x)
Fibonacci-Heap-Decrease-Key(H,x,-infinity)
Fibonacci-Heap-Extract-Min(H)
 </key[y]></key[min[h]]></key[min[h]]></-></code></pre>

<p>关于斐波那契堆的操作具体参见<br><a href="http://gdeepak.com/IADSA/L22binomialfibonacciheaps.pdf" target="_blank" rel="external">http://gdeepak.com/IADSA/L22binomialfibonacciheaps.pdf</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/04/28/Latch/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          Latch
        
      </div>
    </a>
  
  
</nav>

  
</article>




<div class="share_addthis">
  <div class="sharing addthis_toolbox share">
    <a class="addthis_button_facebook_like"></a>
    <a class="addthis_button_tweet"></a>
    <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-560c64c35486b3d4" async="async"></script>
</div>





</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Xudong Zhao&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>